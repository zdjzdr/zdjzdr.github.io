<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2Fcc1b9611.html</url>
    <content type="text"><![CDATA[JavaScript概述ECMAScript和JavaScript的关系996年11月，JavaScript的创造者–Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这门语言能够成为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。 该标准一开始就是针对JavaScript语言制定的，但是没有称其为JavaScript，有两个方面的原因。一是商标，JavaScript本身已被Netscape注册为商标。二是想体现这门语言的制定者是ECMA，而不是Netscape，这样有利于保证这门语言的开发性和中立性。 因此ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。 ECMAScript的历史 年份 名称 描述 1997 ECMAScript 1 第一个版本 1998 ECMAScript 2 版本变更 1999 ECMAScript 3 添加正则表达式添加try/catch ECMAScript 4 没有发布 2009 ECMAScript 5 添加”strict mode”严格模式添加JSON支持 2011 ECMAScript 5.1 版本变更 2015 ECMAScript 6 添加类和模块 2016 ECMAScript 7 增加指数运算符（**）增加Array.prototype.includes 注：ES6就是指ECMAScript 6。 尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。实际上，一个完整的 JavaScript 实现是由以下 3 个不同部分组成的： 核心（ECMAScript） 文档对象模型（DOM） Document object model (整合js，css，html) 浏览器对象模型（BOM） Broswer object model（整合js和浏览器） 简单地说，ECMAScript 描述了JavaScript语言本身的相关内容。 JavaScript 是脚本语言JavaScript 是一种轻量级的编程语言。 JavaScript 是可插入 HTML 页面的编程代码。 JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。 JavaScript 很容易学习。 JavaScript引入方式script标签内写代码123&lt;script&gt; //在这里写代码&lt;/script&gt; 引入外部的JS文件1&lt;script src="myscript.js"&gt;&lt;/script&gt; JavaScript语言规范注释12345// 这是单行注释/*这是多行注释*/ 结束符JavaScript中的语句要以分号（;）为结束符。 JavaScript语言基础变量思维导图 变量声明 JavaScript的变量名可以使用_，数字，字母，$组成，不能以数字开头。 声明变量使用 var 变量名; 的格式来进行声明 1234var name = "dojone";var n = 29;var b =39;var s = n+b; 注意：变量名是区分大小写的（y 和 Y 是不同的变量）。推荐使用驼峰式命名规则。保留字不能用做变量名。 一条语句，多个变量 您可以在一条语句中声明很多变量。该语句以 var 开头，并使用逗号分隔变量即可： 1var lastname="Doe", age=30, job="carpenter"; 声明也可横跨多行： 123var lastname="Doe", age=30, job="carpenter"; Value = undefined在计算机程序中，经常会声明无值的变量。未使用值来声明的变量，其值实际上是 undefined。在执行过以下语句后，变量 carname 的值将是 undefined： 1var carname; 重新声明 JavaScript 变量 如果重新声明 JavaScript 变量，该变量的值不会丢失： 在以下两条语句执行后，变量 carname 的值依然是 “Volvo”： 12var carname="Volvo"; var carname; 补充： ES6新增了let命令，用于声明变量。其用法类似于var，但是所声明的变量只在let命令所在的代码块内有效。例如：for循环的计数器就很适合使用let命令。 1for (let i=0;i&lt;arr.length;i++)&#123;...&#125; ES6新增const用来声明常量。一旦声明，其值就不能改变。 1234const PI = 3.1415;PI // 3.1415PI =3// TypeError: "PI" is read-only 再次补充： 12345678910111213141516171819202122232425262728293031abstractbooleanbytecharclassconstdebuggerdoubleenumexportextendsfinalfloatgotoimplementsimportintinterfacelongnativepackageprivateprotectedpublicshortstaticsupersynchronizedthrowstransientvolatile JavaScript数据类型字符串（String）、数字(Number)、布尔(Boolean)、数组(Array)、对象(Object)、空（Null）、未定义（Undefined）。 JavaScript拥有动态类型 123var x; //此时X是undefinedvar x =1; //此时x是数字var x="dojone"; //此时x是字符串 数据类型思维导图 数字（Number）JavaScript不区分整型和浮点型，就只有一种数字类型。 1234var a = 12.34;var b = 20;var c = 123e5; // 12300000var d = 123e-5; // 0.00123 还有一种NaN，表示不是一个数字（Not a Number）。 常用方法： 123parseInt("123") // 返回123parseInt("ABC") // 返回NaN,NaN属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。parseFloat("123.456") // 返回123.456 字符串（String）字符串是存储字符（比如 “Bill Gates”）的变量。 字符串可以是引号中的任意文本。您可以使用单引号或双引号（由于HTML语言的属性值使用双引号，所以很多项目约定JavaScript语言的字符串只使用单引号）： 12var name="dojone";var name='dojone'; 您可以在字符串中使用引号，只要不匹配包围字符串的引号即可： 123var answer="It's alright";var answer="He is called 'Johnny'";var answer='He is called "Johnny"'; 如果要在单引号字符串的内部，使用单引号（或者在双引号字符串的内部，使用双引号），就必须在内部的单引号（或者双引号）前面加上反斜杠，用来转义。 1234var s1='Did she say \'Hello\'?'// "Did she say 'Hello'?"var s2="Did she say \"Hello\"?"// "Did she say "Hello"?" 字符串默认只能写在一行内，分成多行将会报错。 1234'abc'// SyntaxError: Unexpected token ILLEGAL 上面代码将一个字符串分成三行，JavaScript就会报错。 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 1234567var longString = "Long \long \long \string";longString// "Long long long string" 拼接字符串一般使用“+”,将长字符串拆成多行书写，输出的时候也是单行。 1234var longString = 'Long ' + 'long ' + 'long ' + 'string'; 如果想输出多行字符串，有一种利用多行注释的变通方法。 12345678(function () &#123; /*line 1line 2line 3*/&#125;).toString().split('\n').slice(1, -1).join('\n')// "line 1// line 2// line 3" 上面的例子中，输出的字符串就是多行。 字符串的转义反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。 需要用反斜杠转义的特殊字符，主要有下面这些： \0 null（\u0000） \b 后退键（\u0008） \f 换页符（\u000C） \n 换行符（\u000A） \r 回车键（\u000D） \t 制表符（\u0009） \v 垂直制表符（\u000B） \&#39; 单引号（\u0027） \&quot; 双引号（\u0022） \ 反斜杠（\u005C） 上面这些字符前面加上反斜杠，都表示特殊含义。 123console.log('1\n2');// 1// 2 上面代码中，\n表示换行，输出的时候就分成了两行。 反斜杠还有三种特殊用法。 （1）\HHH 反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的Unicode码点，比如\251表示版权符号。显然，这种方法只能输出256种字符。 （2）\xHH \x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的Unicode码点，比如\xA9表示版权符号。这种方法也只能输出256种字符。 （3）\uXXXX \u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。HHHH对应该字符的Unicode码点，比如\u00A9表示版权符号。 下面是这三种字符特殊写法的例子。 1234567'\251' // "©"'\xA9' // "©"'\u00A9' // "©"'\172' === 'z' // true'\x7A' === 'z' // true'\u007A' === 'z' // true 字符串常用方法 方法 说明 .length 返回长度 .trim() 移除空白 .trimLeft() 移除左边的空白 .trimRight() 移除右边的空白 .charAt(n) 返回第n个字符 .concat(value, …) 拼接 .indexOf(substring, start) 子序列位置 .substring(from, to) 根据索引获取子序列 .slice(start, end) 切片 .toLowerCase() 小写 .toUpperCase() 大写 .split(delimiter, limit) 分割 slice和substring的区别123456789101112131415string.slice(start, stop)和string.substring(start, stop)：两者的相同点：如果start等于end，返回空字符串如果stop参数省略，则取到字符串末如果某个参数超过string的长度，这个参数会被替换为string的长度substirng()的特点：如果 start &gt; stop ，start和stop将被交换如果参数是负数或者不是数字，将会被0替换silce()的特点：如果 start &gt; stop 不会交换两者如果start小于0，则切割从字符串末尾往前数的第abs(start)个的字符开始(包括该位置的字符)如果stop小于0，则切割在从字符串末尾往前数的第abs(stop)个字符结束(不包含该位置字符) 补充： ES6中引入了模板字符串。模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当做普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 12345678// 普通字符串`这是普通字符串！`// 多行文本`这是多行的文本`// 字符串中嵌入变量var name = "q1mi", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 注意： 如果模板字符串中需要使用反引号，则在其前面要用反斜杠转义。 JSHint启用ES6语法支持:/\ jshint esversion: 6 */* 布尔值（Boolean）区别于Python，true和false都是小写。 12var a = true;var b = false; “”(空字符串)、0、null、undefined、NaN都是false。 null和undefined null表示值是空，一般在需要指定或清空一个变量时才会使用，如 name=null; undefined表示当声明一个变量但未初始化时，该变量的默认值是undefined。还有就是函数无明确的返回值时，返回的也是undefined。 null表示变量的值是空，undefined则表示只声明了变量，但还没有赋值。 对象（Object）JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…此外，JavaScript 允许自定义对象。 JavaScript 提供多个内建对象，比如 String、Date、Array 等等。 对象只是带有属性和方法的特殊数据类型。 生成方法对象（object）是JavaScript的核心概念，也是最重要的数据类型。JavaScript的所有数据都可以被视为对象。 简单说，所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成。 123var o = &#123; p: 'Hello World'&#125;; 上面代码中，大括号就定义了一个对象，它被赋值给变量o。这个对象内部包含一个键值对（又称为“成员”），p是“键名”（成员的名称），字符串Hello World是“键值”（成员的值）。键名与键值之间用冒号分隔。如果对象内部包含多个键值对，每个键值对之间用逗号分隔。 1234var o = &#123; p1: 'Hello', p2: 'World'&#125;; 对象的生成方法，通常有三种方法。除了像上面那样直接使用大括号生成（{}），还可以用new命令生成一个Object对象的实例，或者使用Object.create方法生成。 123var o1 = &#123;&#125;;var o2 = new Object();var o3 = Object.create(Object.prototype); 上面三行语句是等价的。一般来说，第一种采用大括号的写法比较简洁，第二种采用构造函数的写法清晰地表示了意图，第三种写法一般用在需要对象继承的场合。 键名对象的所有键名都是字符串，所以加不加引号都可以。上面的代码也可以写成下面这样。 123var o = &#123; 'p': 'Hello World'&#125;; 如果键名是数值，会被自动转为字符串。 123456789101112131415161718var o =&#123; 1: 'a', 3.2: 'b', 1e2: true, 1e-2: true, .234: true, 0xFF: true&#125;;o// Object &#123;// 1: "a",// 3.2: "b",// 100: true,// 0.01: true,// 0.234: true,// 255: true// &#125; 但是，如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号，否则会报错。 12345var o = &#123; '1p': "Hello World", 'h w': "Hello World", 'p+q': "Hello World"&#125;; 上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。 注意，JavaScript的保留字可以不加引号当作键名。 属性对象的每一个“键名”又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。 12345678var o = &#123; p: function (x) &#123; return x * x; &#125;&#125;;o.p(9)// 81 上面的对象就有一个方法p，它就是一个函数。 对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。 1234var o = &#123; p: 123, m: function () &#123; ... &#125;,&#125; 上面的代码中m属性后面的那个逗号，有或没有都不算错。 属性可以动态创建，不必在对象声明时就指定。 123var obj = &#123;&#125;;obj.foo = 123;obj.foo // 123 上面代码中，直接对obj对象的foo属性赋值，结果就在运行时创建了foo属性。 对象的引用如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 12345678var o1 = &#123;&#125;;var o2 = o1;o1.a = 1;o2.a // 1o2.b = 2;o1.b // 2 上面代码中，o1和o2指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。 此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。 12345var o1 = &#123;&#125;;var o2 = o1;o1 = 1;o2 // &#123;&#125; 上面代码中，o1和o2指向同一个对象，然后o1的值变为1，这时不会对o2产生影响，o2还是指向原来的那个对象。 数组数组对象的作用是：使用单独的变量名来存储一系列的值。类似于Python中的列表。每个值的位置都有编号（从0开始），整个数组用方括号表示。 12var a = [123, "ABC"];console.log(a[1]); // 输出"ABC"]]></content>
      <categories>
        <category>编程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS示例-博客（带导航）]]></title>
    <url>%2Fbac94c84.html</url>
    <content type="text"><![CDATA[CSS示例-博客（带导航）本代码用基础的html代码和css代码构成了一个简易博客页面 html代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;博客示例&lt;/title&gt; &lt;link rel="stylesheet" href="c1.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="flu"&gt; &lt;!--导航栏开始--&gt; &lt;div class="nav-top"&gt; &lt;div class="nav"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;标签&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;分类&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;归档&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="register"&gt; &lt;a href=""&gt;注册&lt;/a&gt; &lt;a href=""&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--导航栏结束--&gt; &lt;!--左边栏开始--&gt; &lt;div class="left"&gt; &lt;!--头像--&gt; &lt;div class="head"&gt; &lt;img src="https://img04.sogoucdn.com/app/a/100520093/d71a6360ba8601ff-3cc95dbc4e7ef3af-e99d542fe510b8af4215157258d88b3b.jpg" alt=""&gt; &lt;/div&gt; &lt;!--头像--&gt; &lt;!--主标题--&gt; &lt;div class="title"&gt;&lt;h1&gt;小强的狗窝&lt;/h1&gt;&lt;/div&gt; &lt;!--主标题--&gt; &lt;!--副标题--&gt; &lt;div class="subtitle"&gt;这条狗很懒，什么都没有留下。&lt;/div&gt; &lt;!--副标题--&gt; &lt;!--栏目--&gt; &lt;div class="categeroy"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;关于我&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;关于你&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;关于他&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!--栏目--&gt; &lt;!--标签--&gt; &lt;div class="tags"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;JS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;CSS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;HTML&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!--标签--&gt; &lt;/div&gt; &lt;!--左边栏结束--&gt; &lt;!--右边栏开始--&gt; &lt;div class="right"&gt; &lt;!--文章列表开始--&gt; &lt;div class="artic-list"&gt; &lt;div class="artic"&gt; &lt;p class="head-title"&gt;海燕&lt;/p&gt; &lt;p class="head-date"&gt;2019-04-08&lt;/p&gt; &lt;p class="content-arc"&gt;在苍茫的大海上，狂风卷集着乌云。在乌云和大海之间，海燕像黑色的闪电，在高傲地飞翔。 一会儿翅膀碰着波浪，一会儿箭一般地直冲向乌云，它叫喊着，──就在这鸟儿勇敢的叫喊声里，乌云听出了欢乐。&lt;/p&gt; &lt;div class="tag-div"&gt; &lt;p class="tag-arc"&gt;&lt;a href=""&gt;#HTML&lt;/a&gt;&lt;/p&gt; &lt;p class="tag-arc"&gt;&lt;a href=""&gt;#CSS&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="artic"&gt; &lt;p class="head-title"&gt;海燕&lt;/p&gt; &lt;p class="head-date"&gt;2019-04-08&lt;/p&gt; &lt;p class="content-arc"&gt;在苍茫的大海上，狂风卷集着乌云。在乌云和大海之间，海燕像黑色的闪电，在高傲地飞翔。 一会儿翅膀碰着波浪，一会儿箭一般地直冲向乌云，它叫喊着，──就在这鸟儿勇敢的叫喊声里，乌云听出了欢乐。&lt;/p&gt; &lt;div class="tag-div"&gt; &lt;p class="tag-arc"&gt;&lt;a href=""&gt;#HTML&lt;/a&gt;&lt;/p&gt; &lt;p class="tag-arc"&gt;&lt;a href=""&gt;#CSS&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="artic"&gt; &lt;p class="head-title"&gt;海燕&lt;/p&gt; &lt;p class="head-date"&gt;2019-04-08&lt;/p&gt; &lt;p class="content-arc"&gt;在苍茫的大海上，狂风卷集着乌云。在乌云和大海之间，海燕像黑色的闪电，在高傲地飞翔。 一会儿翅膀碰着波浪，一会儿箭一般地直冲向乌云，它叫喊着，──就在这鸟儿勇敢的叫喊声里，乌云听出了欢乐。&lt;/p&gt; &lt;div class="tag-div"&gt; &lt;p class="tag-arc"&gt;&lt;a href=""&gt;#HTML&lt;/a&gt;&lt;/p&gt; &lt;p class="tag-arc"&gt;&lt;a href=""&gt;#CSS&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--文章列表结束--&gt; &lt;/div&gt; &lt;!--右边栏结束--&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css代码以下是html文件中引用的css代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150* &#123; margin:0; padding:0;&#125;.left &#123; height: 1000px; width: 29%; border: 1px solid black; background-color: #3f3a3a; margin-top: 50px; float: left;&#125;.head &#123; margin: 20px auto; height: 150px; width: 150px; border: 2px solid white; border-radius: 50%; overflow: hidden;&#125;.head&gt;img &#123; max-width: 100%;&#125;.title &#123; margin: 0 auto; color: white;&#125;.title&gt;h1 &#123; text-align: center; color: white;&#125;.subtitle &#123; margin: 10px 30px; color: white; text-align: center; border: 1px solid white; padding: 5px;&#125;.categeroy,.tags&#123; text-align: center; margin-top: 30px;&#125;.categeroy a,.tags a &#123; color: white; text-decoration: none;&#125;.categeroy ul,.tags ul&#123; list-style-type: none;&#125;.categeroy ul li,.tags ul li&#123; padding: 5px 80px;&#125;.tags a:before&#123; content: "#";&#125;.right &#123; height: 1000px; width: 70%; background-color: rgba(128, 128, 128, 0.5); margin-top: 50px; float: right;&#125;.artic-list &#123; margin-top: -30px; margin-left: 30px; margin-right: 80px;&#125;.artic &#123; background-color: white; margin-top: 40px; padding: 20px; border: 1px solid white; border-radius: 10px;&#125;.head-title &#123; font-size: 20px; font-weight: bold; border-left: 3px solid red; padding: 5px; float: left;&#125;.head-date &#123; float: right;&#125;.content-arc &#123; text-indent: 32px; padding-top: 5px; padding-bottom: 10px; clear: both; border-bottom: 1px solid gray;&#125;.content-arc:before&#123; content: "";&#125;.tag-arc &#123; display: inline; padding-right: 10px;&#125;.tag-arc a &#123; text-decoration: none; color: black;&#125;.tag-div &#123; margin-top: 10px;&#125;.nav-top &#123; height: 50px; width: 100%; background-color: black; position: fixed;&#125;.nav &#123; margin-top: 15px; margin-left: 25px; float: left;&#125;.nav ul &#123; list-style-type: none;&#125;.nav ul li,.register a&#123; display: inline; padding: 15px;&#125;.nav ul li a,.register a &#123; color: white; text-decoration: none;&#125;.register &#123; margin-top: 15px; margin-right: 90px; float: right;&#125;.nav ul li a:hover,.register a:hover &#123; color: gray;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2F24caea6b.html</url>
    <content type="text"><![CDATA[1.hexo安装1234npm install hexo-cli -g // 官方带命令行安装npm install hexo -g // 安装npm update hexo -g //升级hexo init //初始化 2.命令说明123456789$ hexo n "博客名称" =&gt; hexo new "博客名称" #这两个都是创建新文章，前者是简写模式$ hexo p =&gt; hexo publish$ hexo g =&gt; hexo generate #生成$ hexo s =&gt; hexo server #启动服务预览$ hexo d =&gt; hexo deploy #部署hexo n //写文章hexo g //生成hexo d -g 可合并 3.关于hexo的服务器命令1234567$ hexo server #Hexo 会监视文件变动并自动更新，无须重启服务器。$ hexo server -s #静态模式$ hexo server -p 5000 #更改端口$ hexo server -i 192.168.1.1 #自定义IP$ hexo clean #清除缓存，网页正常情况下可以忽略此条命令$ hexo g #生成静态网页$ hexo d #开始部署 4.设置文章摘要1以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 3.hexo资料网站1https://hexo.io/zh-cn/]]></content>
      <categories>
        <category>编程</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo及next主题修改]]></title>
    <url>%2F34761dec.html</url>
    <content type="text"><![CDATA[NPM卸载本地包通过npm uninstall &lt;package&gt;命令，你可以将node_modules目录下的某个依赖包移除： 1npm uninstall 包名 要从package.json文件的依赖列表中移除，你需要使用--save标签：1npm uninstall --save 包名 注意：如果你是以开发依赖包（devDependency）的方式安装的（即安装时待--dave -dev标签），那用--save将无法从package.json中移除，你必须用--save -dev标签。 升级Next7.0.0运行如下代码： 12cd hexo/themesgit clone https://github.com/theme-next/hexo-theme-next themes/next7.0.0 这样做有个好处，在hexo/themes/下会生成新旧两个next主题文件夹，我们可以在新旧两个next主题间切换。 7.0.0主题的使用和优化7.0.0主题的的使用在站点根目录下打开_config.yml找到theme，把它改为theme: next7.0.0 Next主题的设定打开themes/next7.0.0下的_config.yml文件，在修改前最好将 _config.yml文件做个备份。找到Schemes修改为自己喜欢的主题样式。 设置语言打开站点根目录下的_config.yml文件，找到language，修改为language: zh-CN 设置菜单打开themes/next7.0.0下的_config.yml文件，找到menu按照自己的需求修改 设置头像把图片放入themes/next7.0.0/source/images下，文件名为avatar01.jgp，并在/themes/next7.0.0/_config.yml中找到avatar修改为： 侧边栏设置打开/themes/next7.0.0下的_config.yml找到social并根据自己的需求修改就行 济览页面时显示进度打开/themes/next7.0.0下的_config.yml找到scrollpercent把false修改为true 代码添加复制按钮并显示复制成功打开/themes/next7.0.0下的_config.yml找到codeblock修改如下： 百度统计登录百度统计打开管理页面下的代码获取，将hm.js?后的ID填入baidu_analytics 开启阅读人数和阅读总人数打开/themes/next7.0.0下的_config.yml找到busuanzi修改如下： 设置文章的阅读时长和字数先安装插件 1npm install hexo-symbols-count-time --save 打开/themes/next7.0.0下的_config.yml找到symbols_count_time修改如下： 站点根目录下_config.yml添加以下内容 1234567symbols_count_time: #文章内是否显示 symbols: true time: true # 网页底部是否显示 total_symbols: true total_time: true 设置网站图标找一张或者自己制作一张32*32 图片，并改各为favicon.ico放到/themes/next7.0.0/source/images里，修改/themes/next7.0.0/_config.yml里的favicon如下： 设置网站运行时间打开hexo\themes\next\layout_paritals\footer.swig文件，在相应位置输入以下代码 1本站已安全运行 90 天 06 小时 00 分 09 秒 Tab tag样式我们先来看一下效果 tab 1 tab 2 选项卡１ 代码： 12345678&#123;% tabs tab %&#125;**选项卡１****选项卡2**&#123;% endtabs %&#125; 然后修改主题配置文件hexo/themes/next7.0/_configl.yml 1234567# Tabs tagtabs: enable: true transition: tabs: true labels: true border_radius: 0 更多详细设置请点击 链接唯一化链接唯一化的好处在于不管你修改多少次文章链接也不会变，当文章标题使用中文时URL也不会出现中文，这样做有利于分享和SEO。 安装hexo-abbrlink插件 1npm install hexo-abbrlink --save 打开站点根目下的_config.yml找到permalink做如下修改： 123456789101112# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://tophat.toproot: /permalink: posts/:abbrlink.html # 默认项 :year/:month/:day/:title/permalink_defaults: # 链接持久化插件abbrlink，添加插件：npm install hexo-abbrlink --saveabbrlink:alg: crc32 # 算法：crc16(default) and crc32rep: hex # 进制：dec(default) and hex 算法和进制的组合如下： 12345678crc16 &amp; hexhttps://post.zz173.com/posts/66c8.htmlcrc16 &amp; dechttps://post.zz173.com/posts/65535.htmlcrc32 &amp; hexhttps://post.zz173.com/posts/8ddf18fb.htmlcrc32 &amp; dechttps://post.zz173.com/posts/1690090958.html 使用crc16算法时文章数上限是65535 今天hexo g时发现页面变成了undefined.html，上网搜了一圈也没找到答案，正准备用其它插件代替时突然发现package.json里没有了abbrlink模块，于是重装模块并hexo cl &amp;&amp; hexo g一切恢复正常。 为外部链接添加nofollow 139139未使用 安装nofollow插件 1npm install hexo-nofollow --save 将以下代码加入到站点根目录下的_config.yml中 1234567# nofollownofollow: enable: true exclude: - exclude1.com - exclude2.comexternal_link: true enable：启用插件 exclude：排除主机名 external_link：添加target=”_blank” 注意：external_link设置在默认的_config.yml中已经有了，只有在找不到的情况下再添加。 修改文章底部的那个带#号的标签修改模板 /themes/next/layout/_macro/post.swig 搜索 rel=”tag”&gt;#，将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 修改网站小图标将图标放入 /themes/next/source/images 修改出题的配置文件 12345favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg 设置站点首页不显示文章全文打开 主题配置文件 _config.yml文件，注意不是站点配置文件，该文件在对应主题文件夹下。找到如下： 12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true #默认为false length: 150 把这里的 false 改为 true 就可以了在首页启动显示文章预览了，length 是显示预览的长度。 这里我们可以通过在文章使用标志来精确控制文章的摘要预览，比如这篇文章就是在这个段落的末尾添加了该标志，所以本文在首页的预览就会显示到这个段落为止。 强烈推荐使用该标志来控制文章的摘要预览，因为这种方式可以让摘要也按照 css 文件中的样式来渲染。如果使用了自动摘要的功能，你会发现文章摘要是一大团没有样式的文本，很是难看。 其他的文章配置（字数统计、阅读时长）1234567891011# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.# 自动将页面滚动到&lt;!-- more --&gt;标记下的地方。scroll_to_more: false# Automatically saving scroll position on each post/page in cookies.# 自动保存每篇文章或页面上一次滚动的地方。save_scroll: false]]></content>
      <categories>
        <category>编程</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS语法-Day48]]></title>
    <url>%2F62b30dec.html</url>
    <content type="text"><![CDATA[CSS的用法-Day48CSS介绍CSS（Cascading Style Sheet，层叠样式表)定义如何显示HTML元素。 当浏览器读到一个样式表，它就会按照这个样式表来对文档进行格式化（渲染）。 CSS语法每个CSS样式由两个组成部分：选择器和声明。声明又包括属性和属性值。每个声明之后用分号结束。 css注释1/*这是注释*/ css的几种引入方式行内样式行内式是在标记的style属性中设定CSS样式。不推荐大规模使用。1&lt;p style="color: red"&gt;Hello world.&lt;/p&gt; 内部样式嵌入式是将CSS样式集中写在网页的&lt;head&gt;&lt;/head&gt;标签对的&lt;style&gt;&lt;/style&gt;标签对中。格式如下：123456789&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; p&#123; background-color: #2b99ff; &#125; &lt;/style&gt;&lt;/head&gt; 外部样式外部样式就是将css写在一个单独的文件中，然后在页面进行引入即可。推荐使用此方式。1&lt;link href="mystyle.css" rel="stylesheet" type="text/css"/&gt; css选择器基本选择器元素选择器1p &#123;color: red;&#125; ID选择器123456.c1 &#123; font-size: 14px;&#125;p.c1 &#123; color: red;&#125; 注意： 样式类名不要用数字开头（有的浏览器不认）。 标签中的class属性如果有多个，要用空格分隔。 通用选择器123* &#123; color: white;&#125; 组合选择器后代选择器12/*li内部的a标签设置字体颜色*/li a &#123; color: green;&#125; 儿子选择器1234/*选择所有父级是 &lt;div&gt; 元素的 &lt;p&gt; 元素*/div&gt;p &#123; font-family: "Arial Black", arial-black, cursive;&#125; 毗邻选择器1234/*选择所有紧接着&lt;div&gt;元素之后的&lt;p&gt;元素*/div+p &#123; margin: 5px;&#125; 弟弟选择器1234/*i1后面所有的兄弟p标签*/#i1~p &#123; border: 2px solid royalblue;&#125; 属性选择器12345678/*用于选取带有指定属性的元素。*/p[title] &#123; color: red;&#125;/*用于选取带有指定属性和值的元素。*/p[title="213"] &#123; color: green;&#125; 不常用的属性选择器12345678910111213141516171819/*找到所有title属性以hello开头的元素*/[title^="hello"] &#123; color: red;&#125;/*找到所有title属性以hello结尾的元素*/[title$="hello"] &#123; color: yellow;&#125;/*找到所有title属性中包含（字符串包含）hello的元素*/[title*="hello"] &#123; color: red;&#125;/*找到所有title属性(有多个值或值以空格分割)中有一个值为hello的元素：*/[title~="hello"] &#123; color: green;&#125; 分组和嵌套分组当多个元素的样式相同的时候，我们没有必要重复地为每个元素都设置样式，我们可以通过在多个选择器之间使用逗号分隔的分组选择器来统一设置元素样式。 例如：123div, p &#123; color: red;&#125; 上面的代码为div标签和p标签统一设置字体为红色。 通常，我们会分两行来写(注意和后代选择器的区别)，更清晰:1234div,p &#123; color: red;&#125; 嵌套多种选择器可以混合起来使用，比如：.c1类内部所有p标签设置字体颜色为红色。123.c1 p &#123; color: red;&#125; 伪类选择器12345678910111213141516171819202122232425/* 未访问的链接 */a:link &#123; color: #FF0000&#125;/* 已访问的链接 */a:visited &#123; color: #00FF00&#125; /* 鼠标移动到链接上 */a:hover &#123; color: #FF00FF&#125; /* 选定的链接 */ a:active &#123; color: #0000FF&#125;/*input输入框获取焦点时样式*/input:focus &#123; outline: none; background-color: #eee;&#125; 伪元素选择器first-letter常用的给首字母设置特殊样式：1234p:first-letter &#123; font-size: 48px; color: red;&#125; before12345/*在每个&lt;p&gt;元素之前插入内容*/p:before &#123; content:"*"; color:red;&#125; after12345/*在每个&lt;p&gt;元素之后插入内容*/p:after &#123; content:"[?]"; color:blue;&#125; 选择器的优先级CSS继承继承是CSS的一个主要特征，它是依赖于祖先-后代的关系的。继承是一种机制，它允许样式不仅可以应用于某个特定的元素，还可以应用于它的后代。例如一个body定义了的字体颜色值也会应用到段落的文本中。123body &#123; color: red;&#125; 此时页面上所有标签都会继承body的字体颜色。然而CSS继承性的权重是非常低的，是比普通元素的权重还要低的0。 我们只要给对应的标签设置字体颜色就可覆盖掉它继承的样式。123p &#123; color: green;&#125; 此外，继承是CSS重要的一部分，我们甚至不用去考虑它为什么能够这样，但CSS继承也是有限制的。有一些属性不能被继承，如：border, margin, padding, background等。 选择器的优先级我们上面学了很多的选择器，也就是说在一个HTML页面中有很多种方式找到一个元素并且为其设置样式，那浏览器根据什么来决定应该应用哪个样式呢？ 其实是按照不同选择器的权重来决定的，具体的选择器权重计算方式如下图：除此之外还可以通过添加 !important方式来强制让样式生效，但并不推荐使用。因为如果过多的使用!important会使样式文件混乱不易维护。万不得已可以使用!important CSS属性相关宽和高width属性可以为元素设置宽度。 height属性可以为元素设置高度。 块级标签才能设置宽度，内联标签的宽度由内容来决定。 字体属性文字字体font-family可以把多个字体名称作为一个“回退”系统来保存。如果浏览器不支持第一个字体，则会尝试下一个。浏览器会使用它可识别的第一个值。 简单实例： 123body &#123; font-family:"Microsoft Yahei","微软雅黑","Arial","sans-serif"&#125; 字体大小123p &#123; font-size:14px;&#125; 如果设置成inherit表示继承父元素的字体大小值。 字重（粗细）font-weight用来设置字体的字重（粗细）。 值 描述 normal 默认值，标准粗细 bold 粗体 bolder 更粗 lighter 更细 100~900 设置具体粗细，400等同于normal，而700等同于bold inherit 继承父元素字体的粗细值 文本颜色颜色属性被用来设置文字的颜色。 颜色是通过CSS最经常的指定： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) 颜色的名称 - 如: red 还有rgba(255,0,0,0.3)，第四个值为alpha, 指定了色彩的透明度/不透明度，它的范围为0.0到1.0之间。 文字属性文字对齐text-align 属性规定元素中的文本的水平对齐方式。 值 描述 left 左边对齐 默认值 right 右对齐 center 居中对齐 justify 两端对齐 文字装饰text-decoration 属性用来给文字添加特殊效果。 值 描述 none 默认。定义标准的文本。 underline 定义文本下的一条线。 overline 定义文本上的一条线。 line-through 定义穿过文本下的一条线。 inherit 继承父元素的text-decoration属性的值。 常用的为去掉a标签默认的自划线： 123a &#123; text-decoration:none;&#125; 首行缩进将段落的第一行缩进 32像素： 123p &#123; text-indent:32px;&#125; 背景属性123456789101112131415/*背景颜色*/background-color: red;/*背景图片*/background-image: url('1.jpg');/* 背景重复 repeat(默认):背景图片平铺排满整个网页 repeat-x：背景图片只在水平方向上平铺 repeat-y：背景图片只在垂直方向上平铺 no-repeat：背景图片不平铺*/background-repeat: no-repeat; /*背景位置*/background-position: right top;/*background-position: 200px 200px;*/ 支持简写： 1background:#ffffff url('1.png') no-repeat right top; background background 简写属性在一个声明中设置所有的背景属性。 可以设置如下属性： background-color background-position background-size background-repeat background-origin background-clip background-attachment background-image 如果不设置其中的某个值，也不会出问题，比如 background:#ff0000 url(‘smiley.gif’); 也是允许的。 通常建议使用这个属性，而不是分别使用单个属性，因为这个属性在较老的浏览器中能够得到更好的支持，而且需要键入的字母也更少。 值 描述 CSS background-color 规定要使用的背景颜色。 1 background-position 规定背景图像的位置。 1 background-size 规定背景图片的尺寸。 3 background-repeat 规定如何重复背景图像。 1 background-origin 规定背景图片的定位区域。 3 background-clip 规定背景的绘制区域。 3 background-attachment 规定背景图像是否固定或者随着页面的其余部分滚动。 1 background-image 规定要使用的背景图像。 1 inherit 规定应该从父元素继承 background 属性的设置。 1 使用背景图片的一个常见案例就是很多网站会把很多小图标放在一张图片上，然后根据位置去显示图片。减少频繁的图片请求。 background-repeatbackground-repeat 属性设置是否及如何重复背景图像。 默认地，背景图像在水平和垂直方向上重复。 值 描述 repeat 默认。背景图像将在垂直方向和水平方向重复。 repeat-x 背景图像将在水平方向重复。 repeat-y 背景图像将在垂直方向重复。 no-repeat 背景图像将仅显示一次。 inherit 规定应该从父元素继承 background-repeat 属性的设置。 background-color可以使用 background-color为元素设置背景色。这个属性接受任何合法的颜色值。 这条规则把元素的背景设置为灰色： 1p &#123;background-color: gray;&#125; 如果您希望背景色从元素中的文本向外少有延伸，只需增加一些内边距： 1p &#123;background-color: gray; padding: 20px;&#125; background-position 可以利用 background-position改变图像在背景中的位置。 下面的例子在 body 元素中将一个背景图像居中放置： 123456body &#123; background-image:url('/i/eg_bg_03.gif'); background-repeat:no-repeat; background-position:center; &#125; 为 background-position属性提供值有很多方法。首先，可以使用一些关键字：top、bottom、left、right和 center。通常，这些关键字会成对出现，不过也不总是这样。还可以使用长度值，如 100px 或 5cm，最后也可以使用百分数值。不同类型的值对于背景图像的放置稍有差异。 图像放置关键字最容易理解，其作用如其名称所表明的。例如，top right 使图像放置在元素内边距区的右上角。 根据规范，位置关键字可以按任何顺序出现，只要保证不超过两个关键字 - 一个对应水平方向，另一个对应垂直方向。 如果只出现一个关键字，则认为另一个关键字是 center。 所以，如果希望每个段落的中部上方出现一个图像，只需声明如下： 123456p &#123; background-image:url('bgimg.gif'); background-repeat:no-repeat; background-position:top; &#125; 下面是等价的位置关键字： 单一关键字 等价的关键字 center center center top top center 或 center top bottom bottom center 或 center bottom right right center 或 center right left left center 或 center left 百分数值的表现方式更为复杂。假设你希望用百分数值将图像在其元素中居中，这很容易： 123456body &#123; background-image:url('/i/eg_bg_03.gif'); background-repeat:no-repeat; background-position:50% 50%; &#125; 这会导致图像适当放置，其中心与其元素的中心对齐。换句话说，百分数值同时应用于元素和图像。也就是说，图像中描述为 50% 50% 的点（中心点）与元素中描述为 50% 50% 的点（中心点）对齐。 如果图像位于 0% 0%，其左上角将放在元素内边距区的左上角。如果图像位置是 100% 100%，会使图像的右下角放在右边距的右下角。 因此，如果你想把一个图像放在水平方向 2/3、垂直方向 1/3 处，可以这样声明： 123456body &#123; background-image:url('/i/eg_bg_03.gif'); background-repeat:no-repeat; background-position:66% 33%; &#125; 长度值解释的是元素内边距区左上角的偏移。偏移点是图像的左上角。 比如，如果设置值为 50px 100px，图像的左上角将在元素内边距区左上角向右 50 像素、向下 100 像素的位置上： 123456body &#123; background-image:url('/i/eg_bg_03.gif'); background-repeat:no-repeat; background-position:50px 100px; &#125; 注意，这一点与百分数值不同，因为偏移只是从一个左上角到另一个左上角。也就是说，图像的左上角与 background-position 声明中的指定的点对齐。 background-attachment 背景关联(背景图像是否固定或者随着页面的其余部分滚动。)如果文档比较长，那么当文档向下滚动时，背景图像也会随之滚动。当文档滚动到超过图像的位置时，图像就会消失。 您可以通过 background-attachment属性防止这种滚动。通过这个属性，可以声明图像相对于可视区是固定的（fixed），因此不会受到滚动的影响： 123456body &#123; background-image:url(/i/eg_bg_02.gif); background-repeat:no-repeat; background-attachment:fixed &#125; background-attachment 属性的默认值是 scroll，也就是说，在默认的情况下，背景会随文档滚动。 边框边框属性 border-width border-style border-color 12345#i1 &#123; border-width: 2px; border-style: solid; border-color: red;&#125; 通常使用简写方式： 123#i1 &#123; border: 2px solid red;&#125; 边框样式 值 描述 none 无边框。 dotted 点状虚线边框。 dashed 矩形虚线边框。 solid 实线边框。 除了可以统一设置边框外还可以单独为某一个边框设置样式，如下所示： 1234567#i1 &#123; border-top-style:dotted; border-top-color: red; border-right-style:solid; border-bottom-style:dotted; border-left-style:none;&#125; border-radius用这个属性能实现圆角边框的效果。 将border-radius设置为长或高的一半即可得到一个圆形。 display属性用于控制HTML元素的显示效果。 值 意义 display:”none” HTML文档中元素存在，但是在浏览器中不显示。一般用于配合JavaScript代码使用。 display:”block” 默认占满整个页面宽度，如果设置了指定宽度，则会用margin填充剩下的部分。 display:”inline” 按行内元素显示，此时再设置元素的width、height、margin-top、margin-bottom和float属性都不会有什么影响。 display:”inline-block” 使元素同时具有行内元素和块级元素的特点。 display:”none”与visibility:hidden的区别： visibility:hidden: 可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。 display:none: 可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。 CSS盒子模型 margin: 用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。 padding: 用于控制内容与边框之间的距离； Border(边框): 围绕在内边距和内容外的边框。 Content(内容): 盒子的内容，显示文本和图像。 看图吧： margin外边距123456.margin-test &#123; margin-top:5px; margin-right:10px; margin-bottom:15px; margin-left:20px;&#125; 推荐使用简写： 123.margin-test &#123; margin: 5px 10px 15px 20px;&#125; 顺序：上右下左 常见居中： 123.mycenter &#123; margin:0 auto;&#125; padding内填充123456.padding-test &#123; padding-top: 5px; padding-right: 10px; padding-bottom: 15px; padding-left: 20px;&#125; 推荐使用简写： 123.padding-test &#123; padding: 5px 10px 15px 20px;&#125; 顺序：上右下左 补充padding的常用简写方式： 提供一个，用于四边； 提供两个，第一个用于上－下，第二个用于左－右； 如果提供三个，第一个用于上，第二个用于左－右，第三个用于下； 提供四个参数值，将按上－右－下－左的顺序作用于四边； float在 CSS 中，任何元素都可以浮动。 浮动元素会生成一个块级框，而不论它本身是何种元素。 关于浮动的两个特点： 浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。 三种取值left：向左浮动 right：向右浮动 none：默认值，不浮动 clearclear属性规定元素的哪一侧不允许其他浮动元素。 值 描述 left 在左侧不允许浮动元素。 right 在右侧不允许浮动元素。 both 在左右两侧均不允许浮动元素。 none 默认值。允许浮动元素出现在两侧。 inherit 规定应该从父元素继承 clear 属性的值。 注意：clear属性只会对自身起作用，而不会影响其他元素。 清除浮动清除浮动的副作用（父标签塌陷问题） 主要有三种方式： 固定高度 伪元素清除法 overflow:hidden 伪元素清除法（使用较多）： 12345.clearfix:after &#123; content: ""; display: block; clear: both;&#125; overflow溢出属性 值 描述 visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 overflow（水平和垂直均设置） overflow-x（设置水平方向） overflow-y（设置垂直方向） 圆形头像示例123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;圆形的头像示例&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; background-color: #eeeeee; &#125; .header-img &#123; width: 150px; height: 150px; border: 3px solid white; border-radius: 50%; overflow: hidden; &#125; .header-img&gt;img &#123; max-width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="header-img"&gt; &lt;img src="https://q1mi.github.io/Blog/asset/img/head_img.jpg" alt=""&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 定位（position)staticstatic 默认值，无定位，不能当作绝对定位的参照物，并且设置标签对象的left、top等值是不起作用的的。 relative(相对定位)相对定位是相对于该元素在文档流中的原始位置，即以自己原始位置为参照物。有趣的是，即使设定了元素的相对定位以及偏移值，元素还占有着原来的位置，即占据文档流空间。对象遵循正常文档流，但将依据top，right，bottom，left等属性在正常文档流中偏移位置。而其层叠通过z-index属性定义。 注意：position：relative的一个主要用法：方便绝对定位元素找到参照物。 absolute(绝对定位)定义：设置为绝对定位的元素框从文档流完全删除，并相对于最近的已定位祖先元素定位，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块（即body元素）。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 重点：如果父级设置了position属性，例如position:relative;，那么子元素就会以父级的左上角为原始点进行定位。这样能很好的解决自适应网站的标签偏离问题，即父级为自适应的，那我子元素就设置position:absolute;父元素设置position:relative;，然后Top、Right、Bottom、Left用百分比宽度表示。 另外，对象脱离正常文档流，使用top，right，bottom，left等属性进行绝对定位。而其层叠通过z-index属性定义。 fixed(固定)fixed：对象脱离正常文档流，使用top，right，bottom，left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。而其层叠通过z-index属性 定义。 注意点： 一个元素若设置了 position:absolute | fixed; 则该元素就不能设置float。这 是一个常识性的知识点，因为这是两个不同的流，一个是浮动流，另一个是“定位流”。但是 relative 却可以。因为它原本所占的空间仍然占据文档流。 在理论上，被设置为fixed的元素会被定位于浏览器窗口的一个指定坐标，不论窗口是否滚动，它都会固定在这个位置。 返回顶部示例代码： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;返回顶部示例&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; background-color: #eeeeee; &#125; .class1 &#123; height: 1500px; background-color: cornflowerblue; &#125; .class2 &#123; padding: 10px; text-align: center; border:1px solid gray; border-radius: 50%; background-color: burlywood; position: fixed; right: 10px; bottom: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="class1"&gt;div&lt;/div&gt;&lt;div class="class2"&gt;Top&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; z-index123#i2 &#123; z-index: 999;&#125; 设置对象的层叠顺序。 z-index 值表示谁压着谁，数值大的压盖住数值小的， 只有定位了的元素，才能有z-index,也就是说，不管相对定位，绝对定位，固定定位，都可以使用z-index，而浮动元素不能使用z-index z-index值没有单位，就是一个正整数，默认的z-index值为0如果大家都没有z-index值，或者z-index值一样，那么谁写在HTML后面，谁在上面压着别人，定位了元素，永远压住没有定位的元素。 从父现象：父亲怂了，儿子再牛逼也没用 自定义模态框示例 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;自定义模态框&lt;/title&gt; &lt;style&gt; .cover &#123; background-color: rgba(0,0,0,0.65); position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 998; &#125; .modal &#123; background-color: white; position: fixed; width: 600px; height: 400px; left: 50%; top: 50%; margin: -200px 0 0 -300px; z-index: 1000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="cover"&gt;&lt;/div&gt;&lt;div class="modal"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; opacity用来定义透明效果。取值范围是0~1，0是完全透明，1是完全不透明。 综合示例-顶部导航菜单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;li标签的float示例&lt;/title&gt; &lt;style&gt; /*清除浏览器默认外边距和内填充*/ * &#123; margin: 0; padding: 0; &#125; a &#123; text-decoration: none; /*去除a标签默认的下划线*/ &#125; .nav &#123; background-color: black; height: 40px; width: 100%; position: fixed; top: 0; &#125; ul &#123; list-style-type: none; /*删除列表默认的圆点样式*/ margin: 0; /*删除列表默认的外边距*/ padding: 0; /*删除列表默认的内填充*/ &#125; /*li元素向左浮动*/ li &#123; float: left; &#125; li &gt; a &#123; display: block; /*让链接显示为块级标签*/ padding: 0 15px; /*设置左右各15像素的填充*/ color: #b0b0b0; /*设置字体颜色*/ line-height: 40px; /*设置行高*/ &#125; /*鼠标移上去颜色变白*/ li &gt; a:hover &#123; color: #fff; &#125; /*清除浮动 解决父级塌陷问题*/ .clearfix:after &#123; content: ""; display: block; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 顶部导航栏 开始 --&gt;&lt;div class="nav"&gt; &lt;ul class="clearfix"&gt; &lt;li&gt;&lt;a href=""&gt;玉米商城&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;MIUI&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;ioT&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;云服务&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;水滴&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;金融&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;优品&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;!-- 顶部导航栏 结束 --&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm常用快捷键及设置]]></title>
    <url>%2Fa609d306.html</url>
    <content type="text"><![CDATA[pycharm常用快捷键 转自：https://www.cnblogs.com/meng-wei-zhi/p/8067570.html 1、编辑（Editing） Ctrl + Space 基本的代码完成（类、方法、属性） Ctrl + Alt + Space 快速导入任意类 Ctrl + Shift + Enter 语句完成 Ctrl + P 参数信息（在方法中调用参数） Ctrl + Q 快速查看文档 F1 外部文档 Shift + F1 外部文档，进入web文档主页 Ctrl + Shift + Z –&gt; Redo 重做 Ctrl + 鼠标 简介/进入代码定义 Ctrl + F1 显示错误描述或警告信息 Alt + Insert 自动生成代码 Ctrl + O 重新方法 Ctrl + Alt + T 选中 Ctrl + / 行注释/取消行注释 Ctrl + Shift + / 块注释 Ctrl + W 选中增加的代码块 Ctrl + Shift + W 回到之前状态 Ctrl + Shift + ]/[ 选定代码块结束、开始 Alt + Enter 快速修正 Ctrl + Alt + L 代码格式化 Ctrl + Alt + O 优化导入 Ctrl + Alt + I 自动缩进 Tab / Shift + Tab 缩进、不缩进当前行 Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板 Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板 Ctrl+V/Shift+Insert 从剪贴板粘贴 Ctrl + Shift + V 从最近的缓冲区粘贴 Ctrl + D 复制选定的区域或行 Ctrl + Y 删除选定的行 Ctrl + Shift + J 添加智能线 Ctrl + Enter 智能线切割 Shift + Enter 另起一行 Ctrl + Shift + U 在选定的区域或代码块间切换 Ctrl + Delete 删除到字符结束 Ctrl + Backspace 删除到字符开始 Ctrl + Numpad+/- 展开/折叠代码块（当前位置的：函数，注释等） Ctrl + shift + Numpad+/- 展开/折叠所有代码块 Ctrl + F4 关闭运行的选项卡 2、查找/替换(Search/Replace) F3 下一个 Shift + F3 前一个 Ctrl + R 替换 Ctrl + Shift + F 或者连续2次敲击shift 全局查找{可以在整个项目中查找某个字符串什么的，如查找某个函数名字符串看之前是怎么使用这个函数的} Ctrl + Shift + R 全局替换 3、运行(Running) Alt + Shift + F10 运行模式配置 Alt + Shift + F9 调试模式配置 Shift + F10 运行 Shift + F9 调试 Ctrl + Shift + F10 运行编辑器配置 Ctrl + Alt + R 运行manage.py任务 4、调试(Debugging) F8 跳过 F7 进入 Shift + F8 退出 Alt + F9 运行游标 Alt + F8 验证表达式 Ctrl + Alt + F8 快速验证表达式 F9 恢复程序 Ctrl + F8 断点开关 Ctrl + Shift + F8 查看断点 5、导航(Navigation) Ctrl + N 跳转到类 Ctrl + Shift + N 跳转到符号 Alt + Right/Left 跳转到下一个、前一个编辑的选项卡 F12 回到先前的工具窗口 Esc 从工具窗口回到编辑窗口 Shift + Esc 隐藏运行的、最近运行的窗口 Ctrl + Shift + F4 关闭主动运行的选项卡 Ctrl + G 查看当前行号、字符号 Ctrl + E 当前文件弹出，打开最近使用的文件列表 Ctrl+Alt+Left/Right 后退、前进 Ctrl+Shift+Backspace 导航到最近编辑区域 Alt + F1 查找当前文件或标识 Ctrl+B / Ctrl+Click 跳转到声明 Ctrl + Alt + B 跳转到实现 Ctrl + Shift + I查看快速定义 Ctrl + Shift + B跳转到类型声明 Ctrl + U跳转到父方法、父类 Alt + Up/Down跳转到上一个、下一个方法 Ctrl + ]/[跳转到代码块结束、开始 Ctrl + F12弹出文件结构 Ctrl + H类型层次结构 Ctrl + Shift + H方法层次结构 Ctrl + Alt + H调用层次结构 F2 / Shift + F2下一条、前一条高亮的错误 F4 / Ctrl + Enter编辑资源、查看资源 Alt + Home显示导航条F11书签开关 Ctrl + Shift + F11书签助记开关 Ctrl + #[0-9]跳转到标识的书签 Shift + F11显示书签 6、搜索相关(Usage Search) Alt + F7/Ctrl + F7文件中查询用法 Ctrl + Shift + F7文件中用法高亮显示 Ctrl + Alt + F7显示用法 7、重构(Refactoring) F5复制F6剪切 Alt + Delete安全删除 Shift + F6重命名 Ctrl + F6更改签名 Ctrl + Alt + N内联 Ctrl + Alt + M提取方法 Ctrl + Alt + V提取属性 Ctrl + Alt + F提取字段 Ctrl + Alt + C提取常量 Ctrl + Alt + P提取参数 8、控制VCS/Local History Ctrl + K提交项目 Ctrl + T更新项目 Alt + Shift + C查看最近的变化 Alt + BackQuote(’)VCS快速弹出 9、模版(Live Templates) Ctrl + Alt + J当前行使用模版 Ctrl +Ｊ插入模版 10、基本(General) Alt + #[0-9]打开相应的工具窗口 Ctrl + Alt + Y同步 Ctrl + Shift + F12最大化编辑开关 Alt + Shift + F添加到最喜欢 Alt + Shift + I根据配置检查当前文件 Ctrl + BackQuote(’)快速切换当前计划 Ctrl + Alt + S 打开设置页 Ctrl + Shift + A查找编辑器里所有的动作 Ctrl + Tab在窗口间进行切换 pycharm常用设置lz提示一下，pycharm中的设置是可以导入和导出的，file&gt;export settings可以保存当前pycharm中的设置为jar文件，重装时可以直接import settings&gt;jar文件，就不用重复配置了。 file -&gt; Setting -&gt;Editor \1. 设置Python自动引入包，要先在 &gt;general &gt; autoimport -&gt; python :show popup ​ 快捷键：Alt + Enter: 自动添加包 \2. “代码自动完成”时间延时设置 > Code Completion -&gt; Auto code completion in (ms):0 -&gt; Autopopup in (ms):500 \3. Pycharm中默认是不能用Ctrl+滚轮改变字体大小的，可以在〉settings-&gt;Editor-&gt;General-&gt;Mouse中勾选(Change font size(Zoom)with Ctrl+Mouse Wheel) \4. 显示“行号”与“空白字符” > Appearance -&gt; 勾选“Show line numbers”、“Show whitespaces”、“Show method separators” \5. 设置编辑器“颜色与字体”主题 > Colors &amp; Fonts -&gt; Scheme name -&gt; 选择”monokai”“Darcula” 说明：先选择“monokai”，再“Save As”为”monokai-pipi”，因为默认的主题是“只读的”，一些字体大小颜色什么的都不能修改，拷贝一份后方可修改！ 修改字体大小 > Colors &amp; Fonts -&gt; Font -&gt; Size -&gt; 设置为“14” \6. 设置缩进符为制表符“Tab” File -&gt; Default Settings -&gt; Code Style -&gt; General -&gt; 勾选“Use tab character” -&gt; Python -&gt; 勾选“Use tab character” -&gt; 其他的语言代码同理设置 \7. 去掉默认折叠 > Code Folding -&gt; Collapse by default -&gt; 全部去掉勾选 \8. pycharm默认是自动保存的，习惯自己按ctrl + s 的可以进行如下设置： ​ > General -&gt; Synchronization -&gt; Save files on frame deactivation 和 Save files automatically if application is idle for .. sec 的勾去掉 ​ > Editor Tabs -&gt; Mark modified tabs with asterisk 打上勾 9.&gt;file and code template&gt;python scripts #!/usr/bin/env python# -- coding: utf-8 --“””title = ‘$Package_name’author = ‘$USER’mtime = ‘$DATE’# code is far away from bugs with the god animal protecting I love animals. They taste delicious. ┏┓ ┏┓ ┏┛┻━━━┛┻┓ ┃ ☃ ┃ ┃ ┳┛ ┗┳ ┃ ┃ ┻ ┃ ┗━┓ ┏━┛ ┃ ┗━━━┓ ┃ 神兽保佑 ┣┓ ┃ 永无BUG！ ┏┛ ┗┓┓┏━┳┓┏┛ ┃┫┫ ┃┫┫ ┗┻┛ ┗┻┛“”” 10 python文件默认编码 File Encodings&gt; IDE Encoding: UTF-8;Project Encoding: UTF-8; \11. 代码自动整理设置 这里line breaks去掉√，否则bar, 和baz会分开在不同行，不好看。 File -&gt; Settings -&gt; appearance \1. 修改IDE快捷键方案 > Keymap 1) execute selection in console : add keymap &gt; ctrl + enter 系统自带了好几种快捷键方案，下拉框中有如“defaul”,“Visual Studio”,在查找Bug时非常有用,“NetBeans 6.5”,“Default for GNOME”等等可选项， 因为“Eclipse”方案比较大众，个人用的也比较多，最终选择了“Eclipse”。 还是有几个常用的快捷键跟Eclipse不一样，为了能修改，还得先对Eclipse方案拷贝一份： (1).代码提示功能，默认是【Ctrl+空格】，现改为跟Eclipse一样，即【Alt+/】 Main menu -&gt; code -&gt; Completion -&gt; Basic -&gt; 设置为“Alt+/” Main menu -&gt; code -&gt; Completion -&gt; SmartType -&gt; 设置为“Alt+Shift+/” 不过“Alt+/”默认又被 Main menu -&gt; code -&gt; Completion -&gt; Basic -&gt; Cyclic Expand Word 占用，先把它删除再说吧（单击右键删除）！ (2).关闭当前文档，默认是【Ctrl+F4】，现改为跟Eclipse一样，即【Ctrl+W】 Main menu -&gt; Window -&gt; Active Tool Window -&gt; Close Active Tab -&gt; 设置为 “Ctrl+F4”; Main menu -&gt; Window -&gt; Editor -&gt; Close -&gt; 设置为 “Ctrl+W”; 2.设置IDE皮肤主题 > Theme -&gt; 选择“Alloy.IDEA Theme” 或者在setting中搜索theme可以改变主题，所有配色统一改变 File &gt; settings &gt; build.excution 每次打开python控制台时自动执行代码 > console &gt; pyconsole 12345678import sys# print('Python %s on %s' % (sys.version, sys.platform))sys.path.extend([WORKING_DIR_AND_PYTHON_PATHS])import osprint('current workdirectory : ', os.getcwd() )import numpy as npimport scipy as spimport matplotlib as mpl 如果安装了ipython，则在pyconsole中使用更强大的ipython > console 选中use ipython if available 这样每次打开pyconsole就会打开ipython Note: 在virtualenv中安装ipython: (ubuntu_env) pika:/media/pika/files/mine/python_workspace/ubuntu_env$pip install ipython File &gt; settings &gt; Languages &amp; Frameworks 如果在项目设置中开启了django支持，打开python console时会自动变成打开django console，当然如果不想这样就关闭项目对django的支持： 如果打开支持就会在 settings &gt; build.excution &gt; console下多显示一个django console: Django console设置如下 1234567import sysprint('Python %s on %s' % (sys.version, sys.platform))import djangoprint('Django %s' % django.get_version())sys.path.extend([WORKING_DIR_AND_PYTHON_PATHS])if 'setup' in dir(django): django.setup()import django_manage_shell; django_manage_shell.run(PROJECT_ROOT) File &gt; settings &gt; Project : initial project project dependencies &gt; LDA &gt; project depends on these projects &gt; 选择sim_cluster就可以在LDA中调用sim_cluster中的包 Pycharm 设置模板默认添加作者时间等信息 使用Pycharm过程中,每次每次新建都需要手动的编写一些项目信息或者文件信息个人信息,如果使用末班的话,很高效很多. 打开Pycharm,选择 File &gt; Settings(Ctrl + Alt + S) 可以使用搜索快速找到”File and Code Templates”, 右侧菜单选择”Python Script”,对模板进行编辑 格式为: ${&lt;variable_name&gt;},如常用的: ${USER} 当前系统用户 ${DATE} 当前系统日期 ${NAME}.py 文件名称 ${TIME} 当前系统时间 ${PRODUCT_NAME} 创建文件的IDE名称 示例如下：12345# _*_coding:utf-8_*_# 作者 :$&#123;USER&#125;# 创建时间：$&#123;DATE&#125;$&#123;TIME&#125;# 文件 ：$&#123;NAME&#125;.py# IDE ：$&#123;PRODUCT_NAME&#125; pycharm环境和路径配置python解释器路径python项目解释器路径用于配置python项目执行的python路径 比如，有的项目是运行的是系统python2.7下的环境；有的是3.4；有的项目使用的是virtualenv的python环境[python虚拟环境配置 - pycharm中的项目配置] 在pycharm &gt; file &gt; settings &gt; project:pythonworkspace &gt; project interpreter &gt; 选择对应项目 &gt; project interpreter中指定python解释器 pycharm中运行configuration有一个选项add content roots to pythonpath 选中后sys.path中会多一整个项目project的路径/media/pika/files/mine/python_workspace，里面的目录就被当成包使用，这样就可以通过from SocialNetworks.SocialNetworks引入不是python包的目录中的文件了。 不过最好使用sys.path.append(os.path.join(os.path.split(os.path.realpath(file))[0],”../..”))来添加，这样在pycharm外也可以运行不出错 。 pycharm中进行python包管理pycharm中的项目中可以包含package、目录（目录名可以有空格）、等等 目录的某个包中的某个py文件要调用另一个py文件中的函数，首先要将目录设置为source root，这样才能从包中至上至上正确引入函数，否则怎么引入都出错： SystemError: Parent module ‘’ not loaded, cannot perform relative import Note:目录 &gt; 右键 &gt; make directory as &gt; source root python脚本解释路径ctrl + shift + f10 / f10 执行python脚本时 当前工作目录cwd为run/debug configurations 中的working directory 可在edit configurations &gt; project or defaults中配置 console执行路径和当前工作目录python console中执行时 cwd为File &gt; settings &gt; build.excution &gt; console &gt; pyconsole中的working directory 并可在其中配置 pycharm配置os.environ环境pycharm中os.environ不能读取到terminal中的系统环境变量 pycharm中os.environ不能读取.bashrc参数 使用pycharm，无论在python console还是在module中使用os.environ返回的dict中都没有~/.bashrc中的设置的变量，但是有/etc/profile中的变量配置。然而在terminal中使用python，os.environ却可以获取~/.bashrc的内容。 解决方法1： 在~/.bashrc中设置的系统环境只能在terminal shell下运行Spark程序才有效，因为.bashrc is only read for interactive shells. 如果要在当前用户整个系统中都有效（包括pycharm等等IDE），就应该将系统环境变量设置在~/.profile文件中。如果是设置所有用户整个系统，修改/etc/profile或者/etc/environment吧。 如SPARK_HOME的设置[Spark：相关错误总结 ] 解决方法2：在代码中设置，这样不管环境有没有问题了 12345678# spark environment settingsimport sys, osos.environ['SPARK_HOME'] = conf.get(SECTION, 'SPARK_HOME')sys.path.append(os.path.join(conf.get(SECTION, 'SPARK_HOME'), 'python'))os.environ["PYSPARK_PYTHON"] = conf.get(SECTION, 'PYSPARK_PYTHON')os.environ['SPARK_LOCAL_IP'] = conf.get(SECTION, 'SPARK_LOCAL_IP')os.environ['JAVA_HOME'] = conf.get(SECTION, 'JAVA_HOME')os.environ['PYTHONPATH'] = '$SPARK_HOME/python/lib/py4j-0.10.3-src.zip:$PYTHONPATH' pycharm配置第三方库代码自动提示Pycharm实用拓展功能pycharm中清除已编译.pyc中间文件选中你的workspace &gt; 右键 &gt; clean python compiled files 还可以自己写一个清除代码 pycharm设置外部工具[python小工具 ]针对当前pycharm中打开的py文件对应的目录删除其中所有的pyc文件。如果是直接运行（而不是在下面的tools中运行），则删除E:\mine\python_workspace\WebSite目录下的pyc文件。 将上面的删除代码改成外部工具PyCharm &gt; settings &gt; tools &gt; external tools &gt; +添加 Name: DelPyc program: $PyInterpreterDirectory$/python Python安装路径 Parameters: $ProjectFileDir$/Oth/Utility/DelPyc.py $FileDir$ Work directory: $FileDir$ Note:Parameters后面的 $FileDir$参数是说，DelPyc是针对当前pycharm中打开的py文件对应的目录删除其中所有的pyc文件。 之后可以通过下面的方式直接执行 Note:再添加一个Tools名为DelPycIn program: Python安装路径，e.g. D:\python3.4.2\python.exe Parameters: E:\mine\python_workspace\Utility\DelPyc.py Work directory 使用变量 $FileDir$ 参数中没有$FileDir$，这样就可以直接删除常用目录r’E:\mine\python_workspace\WebSite’了，两个一起用更方便 代码质量当你在打字的时候，PyCharm会检查你的代码是否符合PEP8。它会让你知道，你是否有太多的空格或空行等等。如果你愿意，你可以配置PyCharm运行pylint作为外部工具。 python2转python3最快方式/usr/bin/2to3 -wn $FileDir$ 这样在pycharm中打开某个文件，右键external tools &gt; py2topy3就可以瞬间将当前文件所在目录下的所有py2转换成py3，是不是很机智！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML-Day47]]></title>
    <url>%2Fbd068a49.html</url>
    <content type="text"><![CDATA[HTML的用法-Day471. Web服务本质123456789101112131415import socketsk = socket.socket()sk.bind(("127.0.0.1", 8080))sk.listen(5)while True: conn, addr = sk.accept() data = conn.recv(8096) conn.send(b"HTTP/1.1 200 OK\r\n\r\n") conn.send(b"&lt;h1&gt;Hello world!&lt;/h1&gt;") conn.close() 浏览器发请求 –&gt; HTTP协议 –&gt; 服务端接收请求 –&gt; 服务端返回响应 –&gt; 服务端把HTML文件内容发给浏览器 –&gt; 浏览器渲染页面 2. HTML是什么？ 超文本标记语言（Hypertext Markup Language, HTML）是一种用于创建网页的标记语言。 本质上是浏览器可识别的规则，我们按照规则写网页，浏览器根据规则渲染我们的网页。对于不同的浏览器，对同一个标签可能会有不同的解释。（兼容性问题） 网页文件的扩展名：.html或.htm3. HTML不是什么？HTML是一种标记语言（markup language），它不是一种编程语言。HTML使用标签来描述网页。4. HTML文档结构最基本的HTML文档：12345678910&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;css样式优先级&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; &lt;!DOCTYPE html&gt;声明为HTML5文档。 、是文档的开始标记和结束的标记。是HTML页面的根元素，在它们之间是文档的头部（head）和主体（body）。 、定义了HTML文档的开头部分。它们之间的内容不会在浏览器的文档窗口显示。包含了文档的元（meta）数据。 、定义了网页标题，在浏览器标题栏显示。 、之间的文本是可见的网页主体内容。 注意：对于中文网页需要使用 &lt;meta charset=&quot;utf-8&quot;&gt;声明编码，否则会出现乱码。有些浏览器会设置 GBK 为默认编码，则你需要设置为 &lt;meta charset=&quot;gbk&quot;&gt;。 5. HTML标签格式 HTML标签是由尖括号包围的关键字，如&lt;html&gt;, &lt;div&gt;等 HTML标签通常是成对出现的，比如：&lt;div&gt;和&lt;/div&gt;，第一个标签是开始，第二个标签是结束。结束标签会有斜线。 也有一部分标签是单独呈现的，比如：&lt;br/&gt;、&lt;hr/&gt;、&lt;img src=&quot;1.jpg&quot; /&gt;等。 标签里面可以有若干属性，也可以不带属性。 标签的语法： &lt;标签名 属性1=“属性值1” 属性2=“属性值2”……&gt;内容部分&lt;/标签名&gt; &lt;标签名 属性1=“属性值1” 属性2=“属性值2”…… /&gt; 几个很重要的属性： id：定义标签的唯一ID，HTML文档树中唯一 class：为html元素定义一个或多个类名（classname）(CSS样式类名) style：规定元素的行内样式（CSS样式） 6. HTML注释1&lt;!--注释内容--&gt; 7. &lt;!DOCTYPE&gt; 标签&lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于 标签之前。 &lt;!DOCTYPE&gt; 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。 8. HTML常用标签8.1 head内常用标签 标签 意义 &lt;title&gt;&lt;/title&gt; 定义网页标题 &lt;style&gt;&lt;/style&gt; 定义内部样式表 &lt;script&gt;&lt;/script&gt; 定义JS代码或引入外部JS文件 &lt;link/&gt; 引入外部样式表文件 &lt;meta/&gt; 定义网页原信息 8.1.1 Meta标签Meta标签介绍： 元素可提供有关页面的元信息（mata-information）,针对搜索引擎和更新频度的描述和关键词。 标签位于文档的头部，不包含任何内容。 提供的信息是用户不可见的。meta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name 属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 1.http-equiv属性：相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。 123456&lt;!--2秒后跳转到对应的网址，注意引号--&gt;&lt;meta http-equiv="refresh" content="2;URL=https://www.oldboyedu.com"&gt;&lt;!--指定文档的编码类型--&gt;&lt;meta http-equiv="content-Type" charset=UTF8"&gt;&lt;!--告诉IE以最高级模式渲染文档--&gt;&lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt; 2.name属性: 主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。12&lt;meta name="keywords" content="meta总结,html meta,meta属性,meta跳转"&gt;&lt;meta name="description" content="老男孩教育Python学院"&gt; 8.2 body内常用标签8.2.1 基本标签（块级标签和内联标签）123456789101112131415161718&lt;b&gt;加粗&lt;/b&gt;&lt;i&gt;斜体&lt;/i&gt;&lt;u&gt;下划线&lt;/u&gt;&lt;s&gt;删除&lt;/s&gt;&lt;p&gt;段落标签&lt;/p&gt;&lt;h1&gt;标题1&lt;/h1&gt;&lt;h2&gt;标题2&lt;/h2&gt;&lt;h3&gt;标题3&lt;/h3&gt;&lt;h4&gt;标题4&lt;/h4&gt;&lt;h5&gt;标题5&lt;/h5&gt;&lt;h6&gt;标题6&lt;/h6&gt;&lt;!--换行--&gt;&lt;br&gt;&lt;!--水平线--&gt;&lt;hr&gt; 8.2.2 特殊字符 内容 对应代码 空格 &nbsp; &gt; &gt; &lt; &lt; &amp; &amp; ¥ &yen; 版权 &copy; 注册 &reg; 8.2.3 div标签和span标签div标签用来定义一个块级元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现。span标签用来定义内联(行内)元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现。 块级元素与行内元素的区别：所谓块元素，是以另起一行开始渲染的元素，行内元素则不需另起一行。如果单独在网页中插入这两个元素，不会对页面产生任何的影响。这两个元素是专门为定义CSS样式而生的。 注意： 关于标签嵌套：通常块级元素可以包含内联元素或某些块级元素，但内联元素不能包含块级元素，它只能包含其它内联元素。 p标签不能包含块级标签，p标签也不能包含p标签。 8.2.4 img标签1&lt;img src="图片的路径" alt="图片未加载成功时的提示" title="鼠标悬浮时提示信息" width="宽" height="高(宽高两个属性只用一个会自动等比缩放)"&gt; 8.2.5 a标签超链接标签 所谓的超链接是指从一个网页指向一个目标的连接关系，这个目标可以是另一个网页，也可以是相同网页上的不同位置，还可以是一个图片，一个电子邮件地址，一个文件，甚至是一个应用程序。1&lt;a href="http://www.oldboyedu.com" target="_blank" &gt;点我&lt;/a&gt; href属性指定目标网页地址。该地址可以有几种类型： 绝对URL - 指向另一个站点（比如 href=&quot;http://www.jd.com） 相对URL - 指当前站点中确切的路径（href=&quot;index.htm&quot;） 锚URL - 指向页面中的锚（href=&quot;#top&quot;） target： _blank表示在新标签页中打开目标网页 _self表示在当前标签页中打开目标网页 8.2.6 列表 无序列表 1234&lt;ul type="disc"&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt;&lt;/ul&gt; type属性： disc（实心圆点，默认值） circle（空心圆圈） square（实心方块） none（无样式） 有序列表 1234&lt;ol type="1" start="2"&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt;&lt;/ol&gt; type属性： 1 数字列表，默认值 A 大写字母 a 小写字母 Ⅰ大写罗马 ⅰ小写罗马 3.标题列表 1234567&lt;dl&gt; &lt;dt&gt;标题1&lt;/dt&gt; &lt;dd&gt;内容1&lt;/dd&gt; &lt;dt&gt;标题2&lt;/dt&gt; &lt;dd&gt;内容1&lt;/dd&gt; &lt;dd&gt;内容2&lt;/dd&gt;&lt;/dl&gt; 8.2.7 表格表格是一个二维数据空间，一个表格由若干行组成，一个行又有若干单元格组成，单元格里可以包含文字、列表、图案、表单、数字符号、预置文本和其它的表格等内容。表格最重要的目的是显示表格类数据。表格类数据是指最适合组织为表格格式（即按行和列组织）的数据。表格的基本结构：1234567891011121314151617181920212223242526&lt;table border="1" cellpadding="5"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;王思&lt;/td&gt; &lt;td&gt;25&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;24&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;刘伟&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 属性: border: 表格边框. cellpadding: 内边距 cellspacing: 外边距. width: 像素 百分比.（最好通过css来设置长宽） rowspan: 单元格竖跨多少行 colspan: 单元格横跨多少列（即合并单元格） 8.2.7.1 pycharm代码批量输入技巧12345678910111213141516171819202122232425262728293031323334351. td*4 再按TAB键 相当于输入4对&lt;td&gt;&lt;/td&gt;标签2. tr&gt;td*4 再按TAB键 :表示tr的子标签*4结果如下： &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;3. tr&gt;td&#123;内容$&#125;*4 再按TAB键：$表示自增数字；&#123;&#125;表示标签内的内容结果如下： &lt;tr&gt; &lt;td&gt;内容1&lt;/td&gt; &lt;td&gt;内容2&lt;/td&gt; &lt;td&gt;内容3&lt;/td&gt; &lt;td&gt;内容4&lt;/td&gt; &lt;/tr&gt;4. tr&gt;td.c1&#123;内容$&#125;*4 在按TAB键：.c1表示CSS类名为c1结果如下： &lt;tr&gt; &lt;td class="c1"&gt;内容1&lt;/td&gt; &lt;td class="c1"&gt;内容2&lt;/td&gt; &lt;td class="c1"&gt;内容3&lt;/td&gt; &lt;td class="c1"&gt;内容4&lt;/td&gt; &lt;/tr&gt;5. tr&gt;td.c1[id=a$]&#123;内容$&#125;*4 在按TAB键：[id=a$]表示id自增结果如下： &lt;tr&gt; &lt;td class="c1" id="a1"&gt;内容1&lt;/td&gt; &lt;td class="c1" id="a2"&gt;内容2&lt;/td&gt; &lt;td class="c1" id="a3"&gt;内容3&lt;/td&gt; &lt;td class="c1" id="a4"&gt;内容4&lt;/td&gt; &lt;/tr&gt;6. 按住ALT键可对多行进行操作，可以多行快速输入属性名称 8.2.8 form功能： 表单用于向服务器传输数据，从而实现用户与Web服务器的交互 表单能够包含input系列标签，比如文本字段、复选框、单选框、提交按钮等等。 表单还可以包含textarea、select、fieldset和 label标签。 表单属性： 属性 描述 accept-charset 规定在被提交表单中使用的字符集（默认：页面字符集）。 action 规定向何处提交表单的地址（URL）（提交页面）。 autocomplete 规定浏览器应该自动完成表单（默认：开启）。 enctype 规定被提交数据的编码（默认：url-encoded）。 method 规定在提交表单时所用的 HTTP 方法（默认：GET）。 name 规定识别表单的名称（对于 DOM 使用：document.forms.name）。 novalidate 规定浏览器不验证表单。 target 规定 action 属性中地址的目标（默认：_self）。 表单元素 基本概念：HTML表单是HTML元素中较为复杂的部分，表单往往和脚本、动态页面、数据处理等功能相结合，因此它是制作动态网站很重要的内容。表单一般用来收集用户的输入信息表单工作原理：访问者在浏览有表单的网页时，可填写必需的信息，然后按某个按钮提交。这些信息通过Internet传送到服务器上。服务器上专门的程序对这些数据进行处理，如果有错误会返回错误信息，并要求纠正错误。当数据完整无误后，服务器反馈一个输入完成的信息。 以下是Django接手上传文件代码 12345678910111213141516171819from django.conf.urls import urlfrom django.shortcuts import HttpResponsedef upload(request): print("request.GET:", request.GET) print("request.POST:", request.POST) if request.FILES: filename = request.FILES["file"].name with open(filename, 'wb') as f: for chunk in request.FILES['file'].chunks(): f.write(chunk) return HttpResponse('上传成功') return HttpResponse("收到了！")urlpatterns = [ url(r'^upload/', upload),] 8.2.8.1 input标签&lt;input&gt; 元素会根据不同的 type 属性，变化为多种形态。 type属性值 表现形式 对应代码 text 单行输入文本 &lt;input type=text&quot; /&gt; password 密码输入框 &lt;input type=&quot;password&quot; /&gt; date 日期输入框 &lt;input type=&quot;date&quot; /&gt; checkbox 复选框 &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt; radio 单选框 &lt;input type=&quot;radio&quot; /&gt; submit 提交按钮 &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; reset 重置按钮 &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt; button 普通按钮 &lt;input type=&quot;button&quot; value=&quot;普通按钮&quot; /&gt; hidden 隐藏输入框 &lt;input type=&quot;hidden&quot; /&gt; file 文本选择框 &lt;input type=&quot;file&quot; /&gt; 属性说明: name：表单提交时的“键”，注意和id的区别 value：表单提交时对应项的值 type=”button”, “reset”, “submit”时，为按钮上显示的文本年内容 type=”text”,”password”,”hidden”时，为输入框的初始值 type=”checkbox”, “radio”, “file”，为输入相关联的值 checked：radio和checkbox默认被选中的项 readonly：text和password设置只读 disabled：所有input均适用 8.2.8.2 select标签123456789101112131415161718192021222324252627&lt;form action="" method="post"&gt; &lt;select name="city" id="city"&gt; &lt;option value="1"&gt;北京&lt;/option&gt; &lt;option selected="selected" value="2"&gt;上海&lt;/option&gt; &lt;option value="3"&gt;广州&lt;/option&gt; &lt;option value="4"&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;select name="" id="2"&gt; &lt;optgroup label="北京"&gt; &lt;option value=""&gt;朝阳区&lt;/option&gt; &lt;option value=""&gt;昌平区&lt;/option&gt; &lt;option value=""&gt;滨江区&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label="四川"&gt; &lt;option value=""&gt;成都市&lt;/option&gt; &lt;option value=""&gt;绵阳市&lt;/option&gt; &lt;option value=""&gt;德阳市&lt;/option&gt; &lt;option value=""&gt;乐山市&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label="重庆市"&gt; &lt;option value=""&gt;渝中区&lt;/option&gt; &lt;option value=""&gt;江北区&lt;/option&gt; &lt;option value=""&gt;南岸区&lt;/option&gt; &lt;option value=""&gt;九龙坡区&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt;&lt;/form&gt; 属性说明： multiple：布尔属性，设置后为多选，否则默认单选 disabled：禁用 selected：默认选中该项 value：定义提交时的选项值 optgroup: 分级显示 8.2.8.3 label标签定义：&lt;label&gt; 标签为 input 元素定义标注（标记）。说明： label 元素不会向用户呈现任何特殊效果。 &lt;label&gt; 标签的 for 属性值应当与相关元素的 id 属性值相同。 1234&lt;form action=""&gt; &lt;label for="username"&gt;用户名&lt;/label&gt; &lt;input type="text" id="username" name="username"&gt;&lt;/form&gt; 8.2.8.4 textarea多行文本123&lt;textarea name="memo" id="memo" cols="30" rows="10"&gt; 默认内容&lt;/textarea&gt; 属性说明： name：名称 rows：行数 cols：列数 disabled：禁用]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLALCheMy用法-Day63]]></title>
    <url>%2F4dacfec5.html</url>
    <content type="text"><![CDATA[SQLALCheMy用法-Day63SQLAlchemy本身无法操作数据库，其必须以来pymsql等第三方插件，Dialect用于和数据API进行交流，根据配置文件的不同调用不同的数据库API，从而实现对数据库的操作，如：12345678910111213MySQL-Python mysql+mysqldb://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt; pymysql mysql+pymysql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;/&lt;dbname&gt;[?&lt;options&gt;] MySQL-Connector mysql+mysqlconnector://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt; cx_Oracle oracle+cx_oracle://user:pass@host:port/dbname[?key=value&amp;key=value...] 更多详见：http://docs.sqlalchemy.org/en/latest/dialects/index.html 1. 内部处理使用 Engine/ConnectionPooling/Dialect 进行数据库操作，Engine使用ConnectionPooling连接数据库，然后再通过Dialect执行SQL语句。12345678910111213141516171819from sqlalchemy import create_engineengine = create_engine("mysql+pymysql://root:123abc@localhost:3306/db1?charset=utf8",max_overflow=5)# 执行SQLcur = engine.execute( "INSERT INTO users(USERNAME, PASSWORD, EMAIL, USERTYPE) VALUES ('高就', '456ab', 'dad@qq.com', 1)")# 获取新插入的自增IDprint(cur.lastrowid)# 执行SQLCur = engine.execute('select * from users')# 获取第一行数据print(cur.fetchone())# 获取第N行数据print(cur.fetchmany(2))# 获取所有数据print(cur.fetchall()) 2.ORM功能使用使用 ORM/Schema Type/SQL Expression Language/Engine/ConnectionPooling/Dialect 所有组件对数据进行操作。根据类创建对象，对象转换成SQL，执行SQL。 2.1 创建表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# Author : 渝周郎# Time : 2019/3/14 21:38from sqlalchemy import create_enginefrom sqlalchemy import Column, Integer, String, ForeignKeyfrom sqlalchemy.ext.declarative import declarative_baseengine = create_engine("mysql+pymysql://root:123456@localhost:3306/db1?charset=utf8",max_overflow=5)Base = declarative_base()# 创建单表1class State(Base): __tablename__ = '国家' id = Column(Integer, primary_key=True, autoincrement=True) name = Column(String(50), nullable=False, unique=True, index=True)class Movies(Base): __tablename__ = '电影信息' id = Column(Integer, primary_key=True, autoincrement=True) name = Column(String(100), nullable=False) tag = Column(String(100), nullable=False) niandai = Column(String(50)) yanyuan = Column(String(100)) jianjie = Column(String(255)) category = Column(String(100)) state_id = Column(Integer, ForeignKey('国家.id'))# 创建单表2class Users(Base): __tablename__ = 'users' id = Column(Integer, primary_key=True) name = Column(String(32)) extra = Column(String(16)) __table_args__ = ( UniqueConstraint('id', 'name', name='uix_id_name'), Index('ix_id_name', 'name', 'extra'), ) # 一对多class Favor(Base): __tablename__ = 'favor' nid = Column(Integer, primary_key=True) caption = Column(String(50), default='red', unique=True) class Person(Base): __tablename__ = 'person' nid = Column(Integer, primary_key=True) name = Column(String(32), index=True, nullable=True) favor_id = Column(Integer, ForeignKey("favor.nid")) # 多对多class Group(Base): __tablename__ = 'group' id = Column(Integer, primary_key=True) name = Column(String(64), unique=True, nullable=False) port = Column(Integer, default=22) class Server(Base): __tablename__ = 'server' id = Column(Integer, primary_key=True, autoincrement=True) hostname = Column(String(64), unique=True, nullable=False) class ServerToGroup(Base): __tablename__ = 'servertogroup' nid = Column(Integer, primary_key=True, autoincrement=True) server_id = Column(Integer, ForeignKey('server.id')) group_id = Column(Integer, ForeignKey('group.id')) def init_db(): Base.metadata.create_all(engine) def drop_db(): Base.metadata.drop_all(engine) 注：设置外检的另一种方式 ForeignKeyConstraint([‘other_id’], [‘othertable.other_id’]) 2.2 操作表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#!/usr/bin/env python# -*- coding:utf-8 -*-from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Indexfrom sqlalchemy.orm import sessionmaker, relationshipfrom sqlalchemy import create_engineengine = create_engine("mysql+pymysql://root:123@127.0.0.1:3306/t1", max_overflow=5)Base = declarative_base()# 创建单表class Users(Base): __tablename__ = 'users' id = Column(Integer, primary_key=True) name = Column(String(32)) extra = Column(String(16)) __table_args__ = ( UniqueConstraint('id', 'name', name='uix_id_name'), Index('ix_id_name', 'name', 'extra'), ) def __repr__(self): return "%s-%s" %(self.id, self.name)# 一对多class Favor(Base): __tablename__ = 'favor' nid = Column(Integer, primary_key=True) caption = Column(String(50), default='red', unique=True) def __repr__(self): return "%s-%s" %(self.nid, self.caption)class Person(Base): __tablename__ = 'person' nid = Column(Integer, primary_key=True) name = Column(String(32), index=True, nullable=True) favor_id = Column(Integer, ForeignKey("favor.nid")) # 与生成表结构无关，仅用于查询方便 favor = relationship("Favor", backref='pers')# 多对多class ServerToGroup(Base): __tablename__ = 'servertogroup' nid = Column(Integer, primary_key=True, autoincrement=True) server_id = Column(Integer, ForeignKey('server.id')) group_id = Column(Integer, ForeignKey('group.id')) group = relationship("Group", backref='s2g') server = relationship("Server", backref='s2g')class Group(Base): __tablename__ = 'group' id = Column(Integer, primary_key=True) name = Column(String(64), unique=True, nullable=False) port = Column(Integer, default=22) # group = relationship('Group',secondary=ServerToGroup,backref='host_list')class Server(Base): __tablename__ = 'server' id = Column(Integer, primary_key=True, autoincrement=True) hostname = Column(String(64), unique=True, nullable=False)def init_db(): Base.metadata.create_all(engine)def drop_db(): Base.metadata.drop_all(engine)Session = sessionmaker(bind=engine)session = Session()# 1. 增obj1 = State(name='日本')session.add(obj1)session.add_all([ State(name='德国'), State(name='美国'), State(name='俄罗斯'), State(name='英国'), State(name='法国'), State(name='印度')])session.commit()# 2.删session.query(State).filter(State.id == 8).delete()session.commit()# 3.改session.query(state).filter(state.id == 7).update(&#123;'name': '韩国'&#125;)session.query(Users).filter(Users.id &gt; 2).update(&#123;Users.name: Users.name + "099"&#125;, synchronize_session=False)session.query(Users).filter(Users.id &gt; 2).update(&#123;"num": Users.num + 1&#125;, synchronize_session="evaluate")session.commit()# 4.查ret = session.query(Users).all()ret = session.query(Users.name, Users.extra).all()ret = session.query(Users).filter_by(name='alex').all()ret = session.query(Users).filter_by(name='alex').first()ret = session.query(Users).filter(text("id&lt;:value and name=:name")).params(value=224, name='fred').order_by(User.id).all()ret = session.query(Users).from_statement(text("SELECT * FROM users where name=:name")).params(name='ed').all()# 5.其他# 条件ret = session.query(Users).filter_by(name='alex').all()ret = session.query(Users).filter(Users.id &gt; 1, Users.name == 'eric').all()ret = session.query(Users).filter(Users.id.between(1, 3), Users.name == 'eric').all()ret = session.query(Users).filter(Users.id.in_([1,3,4])).all()ret = session.query(Users).filter(~Users.id.in_([1,3,4])).all()ret = session.query(Users).filter(Users.id.in_(session.query(Users.id).filter_by(name='eric'))).all()from sqlalchemy import and_, or_ret = session.query(Users).filter(and_(Users.id &gt; 3, Users.name == 'eric')).all()ret = session.query(Users).filter(or_(Users.id &lt; 2, Users.name == 'eric')).all()ret = session.query(Users).filter( or_( Users.id &lt; 2, and_(Users.name == 'eric', Users.id &gt; 3), Users.extra != "" )).all()# 通配符ret = session.query(Users).filter(Users.name.like('e%')).all()ret = session.query(Users).filter(~Users.name.like('e%')).all()# 限制ret = session.query(Users)[1:2]# 排序ret = session.query(Users).order_by(Users.name.desc()).all()ret = session.query(Users).order_by(Users.name.desc(), Users.id.asc()).all()# 分组from sqlalchemy.sql import funcret = session.query(Users).group_by(Users.extra).all()ret = session.query( func.max(Users.id), func.sum(Users.id), func.min(Users.id)).group_by(Users.name).all()ret = session.query( func.max(Users.id), func.sum(Users.id), func.min(Users.id)).group_by(Users.name).having(func.min(Users.id) &gt;2).all()# 连表ret = session.query(Users, Favor).filter(Users.id == Favor.nid).all()ret = session.query(Person).join(Favor).all()ret = session.query(Person).join(Favor, isouter=True).all()# 组合q1 = session.query(Users.name).filter(Users.id &gt; 2)q2 = session.query(Favor.caption).filter(Favor.nid &lt; 2)ret = q1.union(q2).all()q1 = session.query(Users.name).filter(Users.id &gt; 2)q2 = session.query(Favor.caption).filter(Favor.nid &lt; 2)ret = q1.union_all(q2).all()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MSSQL中的多行数据合并到一行]]></title>
    <url>%2F9ced0291.html</url>
    <content type="text"><![CDATA[MSSQL中的多行数据合并到一行 SC表数据如下： student course 张三 大学语文 李四 大学语文 张三 书法鉴赏 张三 音乐欣赏 李四 电影赏析 期望得到的结果如下： student course 张三 大学语文，书法鉴赏，音乐欣赏 李四 大学语文，电影赏析 有两种方式可以实现，一种是函数，一种是FOR XML PATH（SQL2005及以后支持) 创建SC表的代码如下：1234567891011121314151617181920212223242526272829303132333435IF OBJECT_ID(N&apos;SC&apos;) IS NOT NULL BEGIN DROP TABLE SC ENDELSE BEGIN CREATE TABLE SC ( Student NVARCHAR(50), Course NVARCHAR(50) ) INSERT INTO SC SELECT N&apos;张三&apos;,N&apos;大学语文&apos; UNION ALL SELECT N&apos;李四&apos;,N&apos;大学语文&apos; UNION ALL SELECT N&apos;张三&apos;,N&apos;书法鉴赏&apos; UNION ALL SELECT N&apos;张三&apos;,N&apos;音乐赏析&apos; UNION ALL SELECT N&apos;李四&apos;,N&apos;电影赏析&apos; END 方法一：用户自定义函数12345678910111213141516CREATE FUNCTION [dbo].[f_hebin](@sname varchar(50))RETURNS varchar(8000)AS BEGIN DECLARE @course varchar(50) SELECT @course = ISNULL(@course+&apos;,&apos;,&apos;&apos;)+course FROM SC WHERE student=@sname RETURN @course END SELECT DISTINCT [Student] ,dbo.f_hebin([Student]) AS CourseFROM [dbo].[SC] 方法二：FOR XML PATH1234567891011SELECT distinct student,STUFF( ( SELECT &apos;,&apos;+course FROM SC WHERE student=A.student FOR XML PATH(&apos;&apos;) ),1,1,&apos;&apos;)as courseFROM SC AS A 用法说明：①stuff：1、作用stuff(param1, startIndex, length, param2)将param1中自startIndex(SQL中都是从1开始，而非0)起，删除length个字符，然后用param2替换删掉的字符。 2、参数param1一个字符数据表达式。param1可以是常量、变量，也可以是字符列或二进制数据列。startIndex一个整数值，指定删除和插入的开始位置。如果 startIndex或 length 为负，则返回空字符串。如果startIndex比param1长，则返回空字符串。startIndex可以是 bigint 类型。length一个整数，指定要删除的字符数。如果 length 比param1长，则最多删除到param1 中的最后一个字符。length 可以是 bigint 类型。 3、返回类型如果param1是受支持的字符数据类型，则返回字符数据。如果param1是一个受支持的 binary 数据类型，则返回二进制数据。4、备注如果结果值大于返回类型支持的最大值，则产生错误。1234select STUFF(&apos;abcdefg&apos;,1,0,&apos;|zwxy|&apos;) --结果为&apos;|zwxy|abcdefg&apos;select STUFF(&apos;abcdefg&apos;,1,1,&apos;|zwxy|&apos;) --结果为&apos;|zwxy|bcdefg&apos;select STUFF(&apos;abcdefg&apos;,2,1,&apos;|zwxy|&apos;) --结果为&apos;a|zwxy|cdefg&apos;select STUFF(&apos;abcdefg&apos;,2,2,&apos;|zwxy|&apos;) --结果为&apos;a|zwxy|defg&apos; 以上是stuff的用法②for xml path:for xml path有的人可能知道有的人可能不知道，其实它就是将查询结果集以XML形式展现，有了它我们可以简化我们的查询语句实现一些以前可能需要借助函数活存储过程来完成的工作。那么以一个实例为主.我们还是通过列子引入：还是以SC表为例子1SELECT student,course from sc for xml path 结果如下：1234567891011121314151617181920&lt;row&gt; &lt;student&gt;张三&lt;/student&gt; &lt;course&gt;大学语文&lt;/course&gt;&lt;/row&gt;&lt;row&gt; &lt;student&gt;李四&lt;/student&gt; &lt;course&gt;大学语文&lt;/course&gt;&lt;/row&gt;&lt;row&gt; &lt;student&gt;张三&lt;/student&gt; &lt;course&gt;书法鉴赏&lt;/course&gt;&lt;/row&gt;&lt;row&gt; &lt;student&gt;张三&lt;/student&gt; &lt;course&gt;音乐赏析&lt;/course&gt;&lt;/row&gt;&lt;row&gt; &lt;student&gt;李四&lt;/student&gt; &lt;course&gt;电影赏析&lt;/course&gt;&lt;/row&gt; 由此可以看出 FOR XML PATH 可以将查询结果根据行输出成XML各式！而且我们还可以改变XML行节点的名称，代码如下： 1SELECT student,course from sc for xml path(&apos;课程名称&apos;) 看显示结果，原来的行节点&lt;row&gt;变成了我们在PATH后面括号()中自定义的名称&lt;课程名称&gt;： 1234567891011121314151617181920&lt;课程名称&gt; &lt;student&gt;张三&lt;/student&gt; &lt;course&gt;大学语文&lt;/course&gt;&lt;/课程名称&gt;&lt;课程名称&gt; &lt;student&gt;李四&lt;/student&gt; &lt;course&gt;大学语文&lt;/course&gt;&lt;/课程名称&gt;&lt;课程名称&gt; &lt;student&gt;张三&lt;/student&gt; &lt;course&gt;书法鉴赏&lt;/course&gt;&lt;/课程名称&gt;&lt;课程名称&gt; &lt;student&gt;张三&lt;/student&gt; &lt;course&gt;音乐赏析&lt;/course&gt;&lt;/课程名称&gt;&lt;课程名称&gt; &lt;student&gt;李四&lt;/student&gt; &lt;course&gt;电影赏析&lt;/course&gt;&lt;/课程名称&gt; 其实我们还可以改变列节点，还记的给列起别名的关键字AS吗？就是用它!代码如下：1SELECT student as 学生,course as 课程 from sc for xml path(&apos;课程名称&apos;) 显示结果：1234567891011121314151617181920&lt;课程名称&gt; &lt;学生&gt;张三&lt;/学生&gt; &lt;课程&gt;大学语文&lt;/课程&gt;&lt;/课程名称&gt;&lt;课程名称&gt; &lt;学生&gt;李四&lt;/学生&gt; &lt;课程&gt;大学语文&lt;/课程&gt;&lt;/课程名称&gt;&lt;课程名称&gt; &lt;学生&gt;张三&lt;/学生&gt; &lt;课程&gt;书法鉴赏&lt;/课程&gt;&lt;/课程名称&gt;&lt;课程名称&gt; &lt;学生&gt;张三&lt;/学生&gt; &lt;课程&gt;音乐赏析&lt;/课程&gt;&lt;/课程名称&gt;&lt;课程名称&gt; &lt;学生&gt;李四&lt;/学生&gt; &lt;课程&gt;电影赏析&lt;/课程&gt;&lt;/课程名称&gt; 我们还可以构建我们喜欢的输出方式，看代码1SELECT &apos;[&apos;+student +&apos;:&apos;+course+&apos;],&apos; from sc for xml path(&apos;&apos;) 显示结果1[张三:大学语文],[李四:大学语文],[张三:书法鉴赏],[张三:音乐赏析],[李四:电影赏析],]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL语法2（Limit分页、执行计划、慢日志查询）-Day62]]></title>
    <url>%2Fe0d06f40.html</url>
    <content type="text"><![CDATA[MySQL语法2（Limit分页、执行计划、慢日志查询）-Day621. limit分页 无论是否有索引，Limitf分页是一个值得关注的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354每页显示10条：当前 118 120， 125倒序： 大 小 970 7 6 6 5 54 43 3219 98 下一页： select * from tb1 where nid &lt; (select nid from (select nid from tb1 where nid &lt; 当前页最小值 order by nid desc limit 每页数据 *【页码-当前页】) A order by A.nid asc limit 1) order by nid desc limit 10; select * from tb1 where nid &lt; (select nid from (select nid from tb1 where nid &gt; 970 order by nid desc limit 40) A order by A.nid asc limit 1) order by nid desc limit 10;上一页： select * from tb1 where nid &lt; (select nid from (select nid from tb1 where nid &lt; 当前页最大值 order by nid asc limit 每页数据 *【当前页-页码】) A order by A.nid asc limit 1) order by nid desc limit 10; select * from tb1 where nid &lt; (select nid from (select nid from tb1 where nid &lt; 980 order by nid asc limit 20) A order by A.nid desc limit 1) order by nid desc limit 10; 2.执行计划 explain + 查询SQL - 用于显示SQL执行信息参数，根据参考信息可以进行SQL优化type:查询时的访问方式，性能：all &lt; index &lt; range &lt; index_merge &lt; ref_or_null &lt; ref &lt; eq_ref &lt; system/const1234567mysql&gt; explain select * from tb2;+----+-------------+-------+------+---------------+------+---------+------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+---------------+------+---------+------+------+-------+| 1 | SIMPLE | tb2 | ALL | NULL | NULL | NULL | NULL | 2 | NULL |+----+-------------+-------+------+---------------+------+---------+------+------+-------+1 row in set (0.00 sec) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990id 查询顺序标识 如：mysql&gt; explain select * from (select nid,name from tb1 where nid &lt; 10) as B; +----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+ | 1 | PRIMARY | &lt;derived2&gt; | ALL | NULL | NULL | NULL | NULL | 9 | NULL | | 2 | DERIVED | tb1 | range | PRIMARY | PRIMARY | 8 | NULL | 9 | Using where | +----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+ 特别的：如果使用union连接气值可能为null select_type 查询类型 SIMPLE 简单查询 PRIMARY 最外层查询 SUBQUERY 映射为子查询 DERIVED 子查询 UNION 联合 UNION RESULT 使用联合的结果 ... table 正在访问的表名 type 查询时的访问方式，性能：all &lt; index &lt; range &lt; index_merge &lt; ref_or_null &lt; ref &lt; eq_ref &lt; system/const ALL 全表扫描，对于数据表从头到尾找一遍 select * from tb1; 特别的：如果有limit限制，则找到之后就不在继续向下扫描 select * from tb1 where email = &apos;seven@live.com&apos; select * from tb1 where email = &apos;seven@live.com&apos; limit 1; 虽然上述两个语句都会进行全表扫描，第二句使用了limit，则找到一个后就不再继续扫描。 INDEX 全索引扫描，对索引从头到尾找一遍 select nid from tb1; RANGE 对索引列进行范围查找 select * from tb1 where name &lt; &apos;alex&apos;; PS: between and in &gt; &gt;= &lt; &lt;= 操作 注意：!= 和 &gt; 符号 INDEX_MERGE 合并索引，使用多个单列索引搜索 select * from tb1 where name = &apos;alex&apos; or nid in (11,22,33); REF 根据索引查找一个或多个值 select * from tb1 where name = &apos;seven&apos;; EQ_REF 连接时使用primary key 或 unique类型 select tb2.nid,tb1.name from tb2 left join tb1 on tb2.nid = tb1.nid; CONST 常量 表最多有一个匹配行,因为仅有一行,在这行的列值可被优化器剩余部分认为是常数,const表很快,因为它们只读取一次。 select nid from tb1 where nid = 2 ; SYSTEM 系统 表仅有一行(=系统表)。这是const联接类型的一个特例。 select * from (select nid from tb1 where nid = 1) as A; possible_keys 可能使用的索引 key 真实使用的 key_len MySQL中使用索引字节长度 rows mysql估计为了找到所需的行而要读取的行数 ------ 只是预估值 extra 该列包含MySQL解决查询的详细信息 “Using index” 此值表示mysql将使用覆盖索引，以避免访问表。不要把覆盖索引和index访问类型弄混了。 “Using where” 这意味着mysql服务器将在存储引擎检索行后再进行过滤，许多where条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带where子句的查询都会显示“Using where”。有时“Using where”的出现就是一个暗示：查询可受益于不同的索引。 “Using temporary” 这意味着mysql在对查询结果排序时会使用一个临时表。 “Using filesort” 这意味着mysql会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。mysql有两种文件排序算法，这两种排序方式都可以在内存或者磁盘上完成，explain不会告诉你mysql将使用哪一种文件排序，也不会告诉你排序会在内存里还是磁盘上完成。 “Range checked for each record(index map: N)” 这个意味着没有好用的索引，新的索引将在联接的每一行上重新估算，N是显示在possible_keys列中索引的位图，并且是冗余的。详细 更多详见1更多详见2 3. 慢日志查询3.1 配置MySQL自动记录慢日志1234slow_query_log = OFF 是否开启慢日志记录long_query_time = 2 时间限制，超过此时间，则记录slow_query_log_file = /usr/slow.log 日志文件log_queries_not_using_indexes = OFF 为使用索引的搜索是否记录 注： 查看当前配置信息：123 show variables like &apos;%query%&apos;-- 修改当前配置： set global 变量名= 值 3.2 查看MySQL慢日志 mysqldumpslow -s at -a /usr/local/var/mysql/MacBook-Pro-3-slow.log以下是打开的日志文件的一些命令参数1234567891011121314151617181920212223242526"""--verbose 版本--debug 调试--help 帮助 -v 版本-d 调试模式-s ORDER 排序方式 what to sort by (al, at, ar, c, l, r, t), 'at' is default al: average lock time ar: average rows sent at: average query time c: count l: lock time r: rows sent t: query time-r 反转顺序，默认文件倒序拍。reverse the sort order (largest last instead of first)-t NUM 显示前N条just show the top n queries-a 不要将SQL中数字转换成N，字符串转换成S。don't abstract all numbers to N and strings to 'S'-n NUM abstract numbers with at least n digits within names-g PATTERN 正则匹配；grep: only consider stmts that include this string-h HOSTNAME mysql机器名或者IP；hostname of db server for *-slow.log filename (can be wildcard), default is '*', i.e. match all-i NAME name of server instance (if using mysql.server startup script)-l 总时间中不减去锁定时间；don't subtract lock time from total time"""]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL语法（视图、函数、触发器、存储过程、事务、条件语句、循环语句、动态SQL）-Day61]]></title>
    <url>%2Fe2eb133.html</url>
    <content type="text"><![CDATA[MySQL语法（视图、函数、触发器、存储过程、事务、条件语句、循环语句、动态SQL）-Day611. 视图1.1 创建视图1234--格式：CREATE VIEW 视图名称 AS SQL语句CREATE VIEW V1 ASSELECT cid,cname,teacher_id,tname FROM courseLEFT JOIN teacher ON course.teacher_id=teacher.tid 1.2 删除视图12--格式：DROP VIEW 视图名称DROP VIEW V1 1.3 修改视图1234-- 格式：ALTER VIEW 视图名称 AS SQL语句ALTER VIEW V1 ASSELECT cid,cname,tname FROM courseLEFT JOIN teacher ON course.teacher_id=teacher.tid 1.4 使用视图 使用视图时，将其当作表进行操作即可，由于视图是虚拟表，所以无法使用其对真实表进行创建、更新和删除操作，仅能做查询用。1SELECT * FROM V1 2. 触发器 对某个表进行【增/删/改】操作的前后如果希望触发某个特定的行为时，可以使用触发器，触发器用于定制用户对表的行进行【增/删/改】前后的行为。 2.1 创建语法12345678910111213141516171819202122232425262728293031323334353637383940414243444546-- delimiter // 更改mysql语句默认结束符号（默认为;）-- NEW 表示update、insert前的临时表-- OLD 表示delete前的临时表-- NEW表示即将插入的数据行，OLD表示即将删除的数据行。-- 插入前delimiter // CREATE TRIGGER TRI_BEFORE_INSERT_a1 BEFORE INSERT ON a FOR EACH ROWBEGINinsert into b(num) VALUES (NEW.num);END //delimiter ;-- 插入后delimiter //CREATE TRIGGER TRI_AFTER_INSERT_a2 AFTER INSERT ON a FOR EACH ROWBEGININSERT INTO b(num) VALUES(NEW.num+5);END //delimiter ;-- 删除前delimiter //CREATE TRIGGER TRI_BEFORE_DELETE_a3 BEFORE DELETE ON a FOR EACH ROWBEGINdelete from b where num = OLD.num;END //delimiter ;-- 删除后delimiter //CREATE TRIGGER TRI_AFTER_DELETE_a4 AFTER DELETE ON a FOR EACH ROWBEGINdelete from b where num = OLD.num+5;END //delimiter ;-- 更新前delimiter //CREATE TRIGGER TRI_BEFORE_UPDATE_a5 BEFORE UPDATE ON a FOR EACH ROWBEGINUPDATE b set num = NEW.num WHERE b.num = OLD.num; -- a表变动b表相同的数字跟着变动END //delimiter ;-- 更新后delimiter //CREATE TRIGGER TRI_AFTER_UPDATE_a6 AFTER UPDATE ON a FOR EACH ROWBEGINUPDATE b set num = NEW.num WHERE b.num = OLD.num; -- a表变动b表相同的数字跟着变动END //delimiter ; 2.2 删除触发器1DROP TRIGGER 触发器名称; 3.存储过程 存储过程是一个SQL语句集合，当主动去调用存储过程时，其中内部的SQL语句会按照逻辑执行。 3.1 创建存储过程3.1.1 无参数过程12345678delimiter //CREATE PROCEDURE P1()BEGINSELECT * FROM SCORE;END //delimiter ;-- 执行存储过程call P1() 3.1.2 有参数过程 对于存储过程，可以接收参数，其参数有三类： in 仅用于传入参数作用 out 仅用于返回值用 inout 既可以传入又可以当作返回值 123456789101112131415161718192021-- 创建存储过程delimiter //CREATE PROCEDURE P2(in i1 int,in i2 int,inout i3 int,out r1 int)BEGINDECLARE tmp1 int;DECLARE tmp2 int default 0;set tmp1 = 1;set r1 = i1+i2+tmp1+tmp2;set i3 = i3+100;END //delimiter ;-- 执行存储过程set @t1 = 100;set @t2 = 0;call p2(3,4,@t1,@t2);select @t1,@t2; 3.1.2.1 带结果集的存储过程123456delimiter //CREATE PROCEDURE P3()BEGINSELECT * FROM SCORE;END //delimiter ; 3.1.2.2 结果集+OUT值1234567891011121314delimiter //CREATE PROCEDURE P4(in n1 int,inout n3 int,out n2 int)BEGINDECLARE tmp1 int;DECLARE tmp2 int default 0;SELECT * FROM SCORE;SET n2 = n1 + 100;SET n3 = n3 + n1 +100;END //delimiter ; 3.1.2.3 带事务的存储过程12345678910111213141516171819202122232425delimiter //CREATE PROCEDURE P5(OUT return_code tinyint)BEGINDECLARE exit handler for sqlexception BEGIN -- ERROR SET return_code = 1; rollback; END;DECLARE exit handler for sqlwarning BEGIN -- WARNING SET return_code = 2; rollback; END;START TRANSACTION;DELETE FROM b;insert into a(num) values(99);COMMIT;--SUCCESSSET return_code = 0;END //delimiter ; 3.1.2.4 带游标的存储过程12345678910111213141516171819delimiter //CREATE PROCEDURE P6()BEGINdeclare ssid int;declare ssname varchar(50);declare done int default FALSE;declare my_cursor CURSOR FOR SELECT sid,sname from student;declare continue handler for NOT FOUND SET done = TRUE;open my_cursor; eg:LOOP fetch my_cursor into ssid,ssname; if done then leave eg; end if; insert into teacher(tname) values(ssname); END loop eg;CLOSE my_cursor;END //delimiter ; 3.1.2.5 动态执行SQL123456789101112delimiter //CREATE PROCEDURE P7(in nid int)BEGINset @nnid = nid;-- PREPARE 把...准备好PREPARE prod FROM &apos;SELECT * FROM student where sid &gt; ?&apos;;EXECUTE prod USING @nnid;DEALLOCATE PREPARE prod;END //delimiter ; 3.2 删除存储过程1drop procedure proc_name; 3.3 执行存储过程123456789-- 无参数CALL Proc_name()-- 有参数，全inCALL proc_name(参数1，参数2,...)-- 有参数，有in,out,inoutset @t1 = 0;set @t2 = 5;CALL proc_name(1,2,@t1,@t2)SELECT @t1,@t2 123456789# pymysql执行存储过程import pymysqlconn = pymysql.connect(host='localhost', user='root', password='******', database='db1' )cur = conn.cursor(cursor=pymysql.cursors.DictCursor)cur.callproc('p7', args=(1,))ret = cur.fecthall()print(ret)cur.close()conn.close() 3.函数3.1 内置函数 MySQL中提供了许多内置函数，例如：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CHAR_LENGTH(str) 返回值为字符串str 的长度，长度的单位为字符。一个多字节字符算作一个单字符。 对于一个包含五个二字节字符集, LENGTH()返回值为 10, 而CHAR_LENGTH()的返回值为5。 CONCAT(str1,str2,...) 字符串拼接 如有任何一个参数为NULL ，则返回值为 NULL。 CONCAT_WS(separator,str1,str2,...) 字符串拼接（自定义连接符） CONCAT_WS()不会忽略任何空字符串。 (然而会忽略所有的 NULL）。 CONV(N,from_base,to_base) 进制转换 例如： SELECT CONV(&apos;a&apos;,16,2); 表示将 a 由16进制转换为2进制字符串表示 FORMAT(X,D) 将数字X 的格式写为&apos;#,###,###.##&apos;,以四舍五入的方式保留小数点后 D 位， 并将结果以字符串的形式返回。若 D 为 0, 则返回结果不带有小数点，或不含小数部分。 例如： SELECT FORMAT(12332.1,4); 结果为： &apos;12,332.1000&apos; INSERT(str,pos,len,newstr) 在str的指定位置插入字符串 pos：要替换位置其实位置 len：替换的长度 newstr：新字符串 特别的： 如果pos超过原字符串长度，则返回原字符串 如果len超过原字符串长度，则由新字符串完全替换 INSTR(str,substr) 返回字符串 str 中子字符串的第一个出现位置。 LEFT(str,len) 返回字符串str 从开始的len位置的子序列字符。 LOWER(str) 变小写 UPPER(str) 变大写 LTRIM(str) 返回字符串 str ，其引导空格字符被删除。 RTRIM(str) 返回字符串 str ，结尾空格字符被删去。 SUBSTRING(str,pos,len) 获取字符串子序列 LOCATE(substr,str,pos) 获取子序列索引位置 REPEAT(str,count) 返回一个由重复的字符串str 组成的字符串，字符串str的数目等于count 。 若 count &lt;= 0,则返回一个空字符串。 若str 或 count 为 NULL，则返回 NULL 。 REPLACE(str,from_str,to_str) 返回字符串str 以及所有被字符串to_str替代的字符串from_str 。 REVERSE(str) 返回字符串 str ，顺序和字符顺序相反。 RIGHT(str,len) 从字符串str 开始，返回从后边开始len个字符组成的子序列 SPACE(N) 返回一个由N空格组成的字符串。 SUBSTRING(str,pos) , SUBSTRING(str FROM pos) SUBSTRING(str,pos,len) , SUBSTRING(str FROM pos FOR len) 不带有len 参数的格式从字符串str返回一个子字符串，起始于位置 pos。带有len参数的格式从字符串str返回一个长度同len字符相同的子字符串，起始于位置 pos。 使用 FROM的格式为标准 SQL 语法。也可能对pos使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的pos 字符，而不是字符串的开头位置。在以下格式的函数中可以对pos 使用一个负值。 mysql&gt; SELECT SUBSTRING(&apos;Quadratically&apos;,5); -&gt; &apos;ratically&apos; mysql&gt; SELECT SUBSTRING(&apos;foobarbar&apos; FROM 4); -&gt; &apos;barbar&apos; mysql&gt; SELECT SUBSTRING(&apos;Quadratically&apos;,5,6); -&gt; &apos;ratica&apos; mysql&gt; SELECT SUBSTRING(&apos;Sakila&apos;, -3); -&gt; &apos;ila&apos; mysql&gt; SELECT SUBSTRING(&apos;Sakila&apos;, -5, 3); -&gt; &apos;aki&apos; mysql&gt; SELECT SUBSTRING(&apos;Sakila&apos; FROM -4 FOR 2); -&gt; &apos;ki&apos; TRIM([&#123;BOTH | LEADING | TRAILING&#125; [remstr] FROM] str) TRIM(remstr FROM] str) 返回字符串 str ， 其中所有remstr 前缀和/或后缀都已被删除。若分类符BOTH、LEADIN或TRAILING中没有一个是给定的,则假设为BOTH 。 remstr 为可选项，在未指定情况下，可删除空格。 mysql&gt; SELECT TRIM(&apos; bar &apos;); -&gt; &apos;bar&apos; mysql&gt; SELECT TRIM(LEADING &apos;x&apos; FROM &apos;xxxbarxxx&apos;); -&gt; &apos;barxxx&apos; mysql&gt; SELECT TRIM(BOTH &apos;x&apos; FROM &apos;xxxbarxxx&apos;); -&gt; &apos;bar&apos; mysql&gt; SELECT TRIM(TRAILING &apos;xyz&apos; FROM &apos;barxxyz&apos;); -&gt; &apos;barx&apos; 更多函数 —-&gt;中文点击这里官方点击这里 3.2 自定义函数123456789101112delimiter //CREATE FUNCTION F1(i1 int,i2 int)returns intBEGIN DECLARE num int; set num = i1 + i2; return(num);END //delimiter ; 3.3 删除函数1drop function func_name; 3.4 执行函数123456-- 获取返回值DECLARE @i varchar(32);SELECT UPPER(&apos;alex&apos;) into @i;SELECT @i;-- 在查询中使用SELECT F1(100，200),name FROM tb2; 4 .事务4.1 支持事务的存储过程12345678910111213141516171819202122232425262728293031delimiter //CREATE PROCEDURE P5(OUT return_code tinyint)BEGINDECLARE exit handler for sqlexception BEGIN -- ERROR SET return_code = 1; rollback; END;DECLARE exit handler for sqlwarning BEGIN -- WARNING SET return_code = 2; rollback; END;START TRANSACTION;DELETE FROM b;insert into a(num) values(99);COMMIT;--SUCCESSSET return_code = 0;END //delimiter ;-- 执行存储过程DECLARE @n int;set @n = 5;call p5(@n);select @n; 5 .索引 索引，是数据库中专门用于帮助用户快速查询数据的一种数据结构。类似于字典中的目录，查找字典内容时可以根据目录查找到数据的存放位置，然后直接获取即可。MySQL中常见索引有： 普通索引 仅加速查询 唯一索引 加速查询+列值唯一（可以有Null) 主键索引 加速查询+列值唯一+表中只有一个（不可以有null） 组合索引 多列值组成一个索引，专门用于组合搜索，其效率大于索引合并 全文索引 对文本的内容进行分词，进行搜索PS:索引合并：使用多个单列索引组合搜索PS:覆盖索引：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖 5.1 普通索引 普通索引仅有一个功能：加速查询 5.1.1 创建表时建立普通索引1234567create table in1( nid int not null auto_increment primary key, name varchar(32) not null, email varchar(64) not null, extra text, index ix_name (name)) 5.1.2 创建普通索引123create index 索引名称 on 表名（列名）-- 注意：对于创建索引时如果是BLOB 和 TEXT 类型，必须指定length。create index ix_extra on in1(extra(32)); 5.1.3 删除普通索引1drop index 索引名称 on 表名 5.1.4 查看索引1show index from 表名 5.2 唯一索引 唯一索引有两个功能：加速查询 和 唯一约束（可含null） 5.2.1 创建表时建立唯一索引1234567create table in1( nid int not null auto_increment primary key, name varchar(32) not null, email varchar(64) not null, extra text, unique ix_name (name)) 5.2.2 创建唯一索引1create unique index 索引名称 on 表名（列名） 5.2.3 删除唯一索引1drop unique index 索引名称 on 表名 5.3 主键索引 主键有两个功能：加速查询 和 唯一约束（不可含null） 5.3.1 创建表时建立主键索引12345678910111213141516create table in1( nid int not null auto_increment primary key, name varchar(32) not null, email varchar(64) not null, extra text, index ix_name (name))-- 或者create table in1( nid int not null auto_increment, name varchar(32) not null, email varchar(64) not null, extra text, primary key(ni1), index ix_name (name)) 5.3.2 创建主键1alter table 表名 add primary key(列名) 5.3.3 删除唯一索引12alter table 表名 drop primary key;alter table 表名 modify 列名 int,drop primary key; 5.4 组合索引 组合索引是将n个列组合成一个索引其应用场景为：频繁的同时使用n列来进行查询，如：where n1 = ‘alex’ and n2 = 666。 5.4.1 创建表123456create table in3( nid int not null auto_increment primary key, name varchar(32) not null, email varchar(64) not null, extra text) 5.4.2 创建组合索引123456create index 索引名称 on 表名（name,email，...）-- 如上创建组合索引之后，查询：-- name and email -- 使用索引-- name -- 使用索引-- email -- 不使用索引-- 注意：对于同时搜索n个条件时，组合索引的性能好于多个单一索引合并。 5.5 索引补充5.5.1 相关命令(查看表结构、生成表的SQL、查看索引、执行时间)12345678910-- 查看表结构 desc 表名-- 查看生成表的SQL show create table 表名-- 查看索引 show index from 表名-- 查看执行时间 SET profiling =1; SQL... SHOW profiles; 5.5.2 使用索引和不使用索引 由于索引是专门用于加速搜索而生，所以加上索引之后，查询效率会快到飞起来。 1234567891011121314151617-- 有索引mysql&gt; select * from tb1 where name = &apos;wupeiqi-888&apos;;+-----+-------------+---------------------+----------------------------------+---------------------+| nid | name | email | radom | ctime |+-----+-------------+---------------------+----------------------------------+---------------------+| 889 | wupeiqi-888 | wupeiqi888@live.com | 5312269e76a16a90b8a8301d5314204b | 2016-08-03 09:33:35 |+-----+-------------+---------------------+----------------------------------+---------------------+1 row in set (0.00 sec)-- 无索引mysql&gt; select * from tb1 where email = &apos;wupeiqi888@live.com&apos;;+-----+-------------+---------------------+----------------------------------+---------------------+| nid | name | email | radom | ctime |+-----+-------------+---------------------+----------------------------------+---------------------+| 889 | wupeiqi-888 | wupeiqi888@live.com | 5312269e76a16a90b8a8301d5314204b | 2016-08-03 09:33:35 |+-----+-------------+---------------------+----------------------------------+---------------------+1 row in set (1.23 sec) 5.5.3 正确使用索引 数据库表中添加索引后确实会让查询速度起飞，但前提必须是正确的使用索引来查询，如果以错误的方式使用，则即使建立索引也会不奏效。即使建立索引，索引也不会生效： 1234567891011121314151617181920212223242526272829303132- like &apos;%xx&apos; select * from tb1 where name like &apos;%cn&apos;;- 使用函数 select * from tb1 where reverse(name) = &apos;wupeiqi&apos;;- or select * from tb1 where nid = 1 or email = &apos;seven@live.com&apos;; 特别的：当or条件中有未建立索引的列才失效，以下会走索引 select * from tb1 where nid = 1 or name = &apos;seven&apos;; select * from tb1 where nid = 1 or email = &apos;seven@live.com&apos; and name = &apos;alex&apos;- 类型不一致 如果列是字符串类型，传入条件是必须用引号引起来，不然... select * from tb1 where name = 999;- != select * from tb1 where name != &apos;alex&apos; 特别的：如果是主键，则还是会走索引 select * from tb1 where nid != 123- &gt; select * from tb1 where name &gt; &apos;alex&apos; 特别的：如果是主键或索引是整数类型，则还是会走索引 select * from tb1 where nid &gt; 123 select * from tb1 where num &gt; 123- order by select email from tb1 order by name desc; 当根据索引排序时候，选择的映射如果不是索引，则不走索引 特别的：如果对主键排序，则还是走索引： select * from tb1 order by nid desc; - 组合索引最左前缀 如果组合索引为：(name,email) name and email -- 使用索引 name -- 使用索引 email -- 不使用索引 5.5.4 其他注意事项123456789- 避免使用select *- count(1)或count(列) 代替 count(*)- 创建表时尽量时 char 代替 varchar- 表的字段顺序固定长度的字段优先- 组合索引代替多个单列索引（经常使用多个条件查询时）- 尽量使用短索引- 使用连接（JOIN）来代替子查询(Sub-Queries)- 连表时注意条件类型需一致- 索引散列值（重复少）不适合建索引，例：性别不适合 6 .条件语句、循环语句、动态SQL6.1 条件语句12345678910111213delimiter //create procedure proc_if()BEGIN declare i int default 0; if i=1 then select 1; elseif i=2 then select 2; else select 7; end if;END //delimiter ; 6.2 循环语句6.2.1 WHILE循环1234567891011delimiter //create procedure proc_while()begin declare num int; set num=0; while num &lt; 10 DO select num; set num=num+1; end while;end //delimiter ; 6.2.2 repeat循环123456789101112delimiter //create procedure proc_repeat()begin declare i int; set i=0; repeat select i; set i=i+1; until i&gt;=5 end repeat;end //delimiter ; 6.2.3 loop循环12345678910begin declare i int default 0; loop_label:loop set i=i+1; if i&lt;8 then iterate loop_label; end if; select i; end loop loop_label;end 6.3 动态执行SQL语句123456789101112delimiter //drop procedure if exists proc_sql //create procedure proc_sql()begin declare p1 int; set p1 = 11; set @p1 = p1; prepare prod from &apos;select * from c where id &gt; ?&apos;; execute prod using @p1; deallocate prepare prod;end //delimiter ;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL语法-Day57]]></title>
    <url>%2F8eb5804a.html</url>
    <content type="text"><![CDATA[MySQL语法-Day571. 用户、权限操作1.1 用户操作1234567891011-- 创建用户(root账号登陆服务器)-- create user &apos;用户名&apos;@&apos;ip地址&apos; identified by &apos;密码&apos; ip地址为 % 表示 所有地址--- 都可以登陆 use mysql create user &apos;dbuser1&apos;@&apos;%&apos; identified by &apos;123456&apos;;-- 删除用户drop user &apos;用户名&apos;@&apos;IP地址&apos;;-- 修改用户rename user &apos;用户名&apos;@&apos;IP地址&apos; to &apos;新用户名&apos;@&apos;IP地址&apos;;-- 修改密码set password for &apos;用户名&apos;@&apos;IP地址&apos; = Password(&apos;新密码&apos;)-- ps:用户权限相关数据保存在mysql数据库的user表中，也可以直接对其进行操作（不建议） 1.2 权限操作1234567891011-- 查看权限show grants for &apos;用户&apos;@&apos;IP地址&apos;;-- 设置权限grant 权限 on 数据库.表 to &apos;用户&apos;@&apos;IP地址&apos;;-- grant select,insert,update,delete on 数据库.表 to 用户名@ip地址 grant select,insert,update on db1.* to &apos;dbuser1&apos;@&apos;%&apos;; -- 上句表示在dbl数据库的所有表中分配select,insert,update的权限给用户dbuser1 grant all privileges on *.* to &apos;zdj&apos;@&apos;%&apos;; -- 上句表示在所有数据库中分配所有权限给用户zdj-- 取消权限remove 权限 on 数据库.表 from &apos;用户&apos;@&apos;IP地址&apos;; 1.2.1 权限说明 all privileges 除grant外的所有权限 select 仅查权限 select,insert 查和插入权限 usage 无访问权限 alter 使用alter table alter routine 使用alter procedure和drop procedure create 使用create table create routine 使用create procedure create temporary tables 使用create temporary tables create user 使用create user、drop user、rename user和revoke all privileges create view 使用create view delete 使用delete drop 使用drop table execute 使用call和存储过程 file 使用select into outfile 和 load data infile grant option 使用grant 和 revoke index 使用index insert 使用insert lock tables 使用lock table process 使用show full processlist select 使用select show databases 使用show databases show view 使用show view update 使用update reload 使用flush shutdown 使用mysqladmin shutdown(关闭MySQL) super 使用change master、kill、logs、purge、master和set global。还允许`mysqladmin`调试登陆 replication client 服务器位置的访问 replication slave 由复制从属使用 1.2.2 目标数据库说明 数据库名.* 数据库中的所有 数据库名.表 指定数据库中的某张表 数据库名.存储过程 指定数据库中的存储过程 `*.* ` 所有数据库 用户名@IP地址 用户只能在改IP下才能访问 用户名@192.168.1.% 用户只能在改IP段下才能访问(通配符%表示任意) 用户名@% 用户可以再任意IP下访问(默认IP地址为%) 2. 数据库操作2.1 显示数据库1show databases; 2.2 创建数据库123-- create database 数据库名 default charset utf8;create database db3 default charset utf8; -- 以上语句表示创建一个叫db3的数据库，编码方式为 utf8,支持中文 2.3 使用数据库12use db3; -- 以上语句表示 选择数据库db3 2.4 删除数据库12drop database db3; -- 以上语句表示 删除数据库db3 3.数据表操作3.1 创建表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465-- 查看表show tables;-- 创建表-- create table 表名（数据列 类型|null|not null|auto_increment primary key) engine=innodb default charset=utf8;create table t1(id int not null auto_increment primary key,name varchar(25),age int)engine=innodb default charset=utf8;-- 设置是否为空-- 是否可空，null表示空，非字符串 -- not null - 不可空 -- null - 可空-- 设置默认值-- 默认值，创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值 create table tb1( nid int not null defalut 2, num int not null )-- 设置自增-- 自增，如果为某列设置自增列，插入数据时无需设置此列，默认将自增（表中只能有一个自增列） create table tb1( nid int not null auto_increment primary key, num int null ) -- 或 create table tb1( nid int not null auto_increment, num int null, index(nid) ) -- 注意：1、对于自增列，必须是索引（含主键）。 -- 2、对于自增可以设置步长和起始值 show session variables like &apos;auto_inc%&apos;; set session auto_increment_increment=2; set session auto_increment_offset=10; shwo global variables like &apos;auto_inc%&apos;; set global auto_increment_increment=2; set global auto_increment_offset=10;-- 设置主键-- 主键，一种特殊的唯一索引，不允许有空值，如果主键使用单个列，则它的值必须唯一，如果是多列，则其组合必须唯一。 create table tb1( nid int not null auto_increment primary key, num int null ) -- 或 create table tb1( nid int not null, num int not null, primary key(nid,num) )-- 设置外键-- 外键，一个特殊的索引，只能是指定内容 creat table color( nid int not null primary key, name char(16) not null ) create table fruit( nid int not null primary key, smt char(32) null , color_id int not null, constraint fk_cc foreign key (color_id) references color(nid) ) 3.2 查看表的结构12-- describe可以简写成descdescribe t1; 3.3 修改表123456789101112131415161718192021-- 添加列：alter table 表名 add 列名 类型-- 删除列：alter table 表名 drop column 列名-- 修改列：alter table 表名 modify column 列名 类型; -- 类型alter table 表名 change 原列名 新列名 类型; -- 列名，类型 -- 添加主键：alter table 表名 add primary key(列名);-- 删除主键：alter table 表名 drop primary key;alter table 表名 modify 列名 int, drop primary key;-- 添加外键：alter table 从表 add constraint 外键名称（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段);-- 删除外键：alter table 表名 drop foreign key 外键名称-- 修改默认值：ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;-- 删除默认值：ALTER TABLE testalter_tbl ALTER i DROP DEFAULT; 3.4 清空表1234-- 第一种方法,下次插入数据后自增列会从上次继续编号delete from t1;-- 第二种方法，下次插入数据后自增列从1开始编号truncate table t1; 3.5 删除表12-- 删除表drop table t1; 3.6 表的数据操作3.6.1 数据类型MySQL的数据类型大致分为：数值、时间和字符串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576bit[(M)] 二进制位（101001），m表示二进制位的长度（1-64），默认m＝1 tinyint[(m)] [unsigned] [zerofill] 小整数，数据类型用于保存一些范围的整数数值范围： 有符号： -128 ～ 127. 无符号：～ 255 特别的： MySQL中无布尔值，使用tinyint(1)构造。 int[(m)][unsigned][zerofill] 整数，数据类型用于保存一些范围的整数数值范围： 有符号： -2147483648 ～ 2147483647 无符号：～ 4294967295 特别的：整数类型中的m仅用于显示，对存储范围无限制。例如： int(5),当插入数据2时，select 时数据显示为： 00002 bigint[(m)][unsigned][zerofill] 大整数，数据类型用于保存一些范围的整数数值范围： 有符号： -9223372036854775808 ～ 9223372036854775807 无符号：～ 18446744073709551615 decimal[(m[,d])] [unsigned] [zerofill] 准确的小数值，m是数字总个数（负号不算），d是小数点后个数。 m最大值为65，d最大值为30。 特别的：对于精确数值计算时需要用此类型 decaimal能够存储精确值的原因在于其内部按照字符串存储。 FLOAT[(M,D)] [UNSIGNED] [ZEROFILL] 单精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。 无符号： -3.402823466E+38 to -1.175494351E-38, 1.175494351E-38 to 3.402823466E+38 有符号： 1.175494351E-38 to 3.402823466E+38 **** 数值越大，越不准确 **** DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL] 双精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。 无符号： -1.7976931348623157E+308 to -2.2250738585072014E-308 2.2250738585072014E-308 to 1.7976931348623157E+308 有符号： 2.2250738585072014E-308 to 1.7976931348623157E+308 **** 数值越大，越不准确 **** char (m) char数据类型用于表示固定长度的字符串，可以包含最多达255个字符。其中m代表字符串的长度。 PS: 即使数据小于m长度，也会占用m长度 varchar(m) varchars数据类型用于变长的字符串，可以包含最多达255个字符。其中m代表该数据类型所允许保存的字符串的最大长度，只要长度小于该最大值的字符串都可以被保存在该数据类型中。 注：虽然varchar使用起来较为灵活，但是从整个系统的性能角度来说，char数据类型的处理速度更快，有时甚至可以超出varchar处理速度的50%。因此，用户在设计数据库时应当综合考虑各方面的因素，以求达到最佳的平衡 text text数据类型用于保存变长的大字符串，可以组多到65535 (2**16 − 1)个字符。 mediumtext A TEXT column with a maximum length of 16,777,215 (2**24 − 1) characters. longtext A TEXT column with a maximum length of 4,294,967,295 or 4GB (2**32 − 1) characters. enum 枚举类型， An ENUM column can have a maximum of 65,535 distinct elements. (The practical limit is less than 3000.) 示例： CREATE TABLE shirts ( name VARCHAR(40), size ENUM(&apos;x-small&apos;, &apos;small&apos;, &apos;medium&apos;, &apos;large&apos;, &apos;x-large&apos;) ); INSERT INTO shirts (name, size) VALUES (&apos;dress shirt&apos;,&apos;large&apos;), (&apos;t-shirt&apos;,&apos;medium&apos;),(&apos;polo shirt&apos;,&apos;small&apos;); set 集合类型 A SET column can have a maximum of 64 distinct members. 示例： CREATE TABLE myset (col SET(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;)); INSERT INTO myset (col) VALUES (&apos;a,d&apos;), (&apos;d,a&apos;), (&apos;a,d,a&apos;), (&apos;a,d,d&apos;), (&apos;d,a,d&apos;); DATE YYYY-MM-DD（1000-01-01/9999-12-31） TIME HH:MM:SS（&apos;-838:59:59&apos;/&apos;838:59:59&apos;） YEAR YYYY（1901/2155） DATETIME YYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00/9999-12-31 23:59:59 Y） TIMESTAMP YYYYMMDD HHMMSS（1970-01-01 00:00:00/2037 年某时） 3.6.2 插入数据1234insert into t1(name,age) values(&apos;wx&apos;,28);insert into t1(name,age) values(&apos;df&apos;,48);insert into t1(name,age) values(&apos;er&apos;,22);insert into t1(name,age) values(&apos;刘德华&apos;,58); 3.6.3 查询数据1select * from t1; 3.6.4 修改数据1update t1 set name=&apos;庞龙&apos; where id =1;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO多路复用-Day42]]></title>
    <url>%2Fcc98eab6.html</url>
    <content type="text"><![CDATA[IO多路复用-Day421. socket端代码123456789101112131415161718192021222324252627# Author : 渝周郎# Time : 2019/1/14 20:21import socketimport selectsk = socket.socket()sk.bind(('127.0.0.1', 4567))sk.listen()sk_list = [sk]while True: r_list, w_list, x_list = select.select(sk_list, [], []) for i in r_list: if i is sk: # 判断i是否为socket对象 conn, addr = i.accept() sk_list.append(conn) else: # 当i为conn时 ret = i.recv(1024) if ret == b'': i.close() sk_list.remove(i) continue print(ret) i.send(b'hello') 2. client端代码1234567891011121314151617# Author : 渝周郎# Time : 2019/1/14 20:21import socketfrom threading import Threadsk = socket.socket()sk.connect(('127.0.0.1', 4567))def func(): sk.send(b'goodbye') ret = sk.recv(1024) print(ret)for i in range(5): Thread(target=func).start() 运行结果如下:]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协程应用举例-Day42]]></title>
    <url>%2Fc41d5ef3.html</url>
    <content type="text"><![CDATA[协程应用举例-Day421. 爬虫123456789101112131415161718192021222324252627# Author : 渝周郎# Time : 2019/1/10 21:55from gevent import monkey;monkey.patch_all()import geventfrom urllib.request import urlopendef get_url(url): response = urlopen(url) context = response.read().decode('utf-8') return url, len(context)urls = ['http://www.baidu.com', 'http://www.sohu.com', 'http://www.cnblogs.com', 'http://www.360.cn', 'http://139139.cn' ]g_lst = []for url in urls: g = gevent.spawn(get_url, url) g_lst.append(g)for gg in g_lst: gg.join() print(gg.value) 运行结果如下: 2. 通过gevent实现单线程下的socket并发2.1 server端代码1234567891011121314151617181920212223from gevent import monkey;monkey.patch_all()import socketimport geventsk = socket.socket()sk.bind(('127.0.0.1', 4567))sk.listen()def get_conn(conn): conn.send(b'hello') rev = conn.recv(1024).decode('utf-8') print(rev) conn.close()while True: conn, addr = sk.accept() print(conn.getsockname()) gevent.spawn(get_conn,conn)sk.close() 2.2 client端代码12345678910import socketsk = socket.socket()sk.connect(('127.0.0.1', 4567))while True: rev = sk.recv(1024).decode('utf-8') print(rev) msg = input('&gt;&gt;&gt;').encode('utf-8') sk.send(msg)sk.close()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协程之gevent模块-Day42]]></title>
    <url>%2Fd0b23dee.html</url>
    <content type="text"><![CDATA[协程之gevent模块-Day421. 用法介绍1234567891011g1=gevent.spawn(func,1,,2,3,x=4,y=5)创建一个协程对象g1，spawn括号内第一个参数是函数名，如eat，后面可以有多个参数，可以是位置实参或关键字实参，都是传给函数eat的g2=gevent.spawn(func2)g1.join() #等待g1结束g2.join() #等待g2结束#或者上述两步合作一步：gevent.joinall([g1,g2])g1.value#拿到func1的返回值 2. IO主动切换1234567891011121314151617181920212223import timeimport geventdef eat(): print('开始吃饭') # time.sleep(2) # gevent模块无法感知time.sleep等IO操作，只能使用自身的sleep；除非在程序最顶端引用monkey.patch_all() gevent.sleep(2) print('结束吃饭')def play(): print('开始玩耍') # time.sleep(2) gevent.sleep(2) print('结束玩耍')g1 = gevent.spawn(eat)g2 = gevent.spawn(play)g1.join()g2.join() 上例gevent.sleep(2)模拟的是gevent可以识别的io阻塞,而time.sleep(2)或其他的阻塞,gevent是不能直接识别的需要用下面一行代码,打补丁,就可以识别了from gevent import monkey;monkey.patch_all()必须放到被打补丁者的前面，如time，socket模块之前或者我们干脆记忆成：要用gevent，需要将from gevent import monkey;monkey.patch_all()放到文件的开头见下面的代码12345678910111213141516171819202122from gevent import monkey;monkey.patch_all()import timeimport geventdef eat(): print('开始吃饭') time.sleep(2) print('结束吃饭')def play(): print('开始玩耍') time.sleep(2) print('结束玩耍')g1 = gevent.spawn(eat)g2 = gevent.spawn(play)g1.join()g2.join() 3. gevent的同步与异步1234567891011121314151617181920212223242526272829303132# Author : 渝周郎# Time : 2019/01/10 21:08from gevent import monkey;monkey.patch_all()import timeimport geventdef task(): time.sleep(1) # IO操作 print('%s :hello.'% time.strftime('%Y-%m-%d %H:%M:%S'))def sync_tb(): print('***同步运行任务开始***') for i in range(5): task() print('***同步运行任务结束***')def async_yb(): print('***异步运行任务开始***') g_lst = [] for i in range(5): g = gevent.spawn(task) g_lst.append(g) gevent.joinall(g_lst) print('***异步运行任务结束***')sync_tb()async_yb() 运行结果如下:]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程之线程池-Day41]]></title>
    <url>%2Fa63938ae.html</url>
    <content type="text"><![CDATA[线程之线程池-Day41 介绍concurrent.futures模块提供了高度封装的异步调用接口ThreadPoolExecutor：线程池，提供异步调用ProcessPoolExecutor: 进程池，提供异步调用Both implement the same interface, which is defined by the abstract Executor class. 基本方法#submit(fn, args, **kwargs)异步提交任务#map(func, iterables, timeout=None, chunksize=1)取代for循环submit的操作#shutdown(wait=True)相当于进程池的pool.close()+pool.join()操作wait=True，等待池内所有任务执行完毕回收完资源后才继续wait=False，立即返回，并不会等待池内的任务执行完毕但不管wait参数为何值，整个程序都会等到所有任务执行完毕submit和map必须在shutdown之前#result(timeout=None)取得结果#add_done_callback(fn)回调函数 代码如下：12345678910111213141516171819202122232425262728# Author : 渝周郎# Time : 2018/12/28 21:09# concurrent.futures模块提供了高度封装的异步调用接口# ThreadPoolExecutor：线程池，提供异步调用# ProcessPoolExecutor: 进程池，提供异步调用import timefrom concurrent.futures import ThreadPoolExecutort_pool = ThreadPoolExecutor(max_workers=5) # 同时运行5个线程,最大线程数不能超过CPU个数*5def func(n): time.sleep(2) print(n) return n*n# submit(fn, *args, **kwargs) 异步提交任务t_lst = []for i in range(20): # 可以用 t_pool.map(func, range(20)) 取代for循环submit的操作 t = t_pool.submit(func, i) t_lst.append(t)t_pool.shutdown() # shutdown(wait=True) 相当于进程池的pool.close()+pool.join()操作print('主线程')for t in t_lst: print('-'*10, t.result()) # result()获取函数结果 运行结果如下:]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程之队列-Day41]]></title>
    <url>%2Fb0bad46c.html</url>
    <content type="text"><![CDATA[线程之队列-Day41代码如下：12345678910111213141516171819202122232425262728# Author : 渝周郎# Time : 2018/12/28 20:24import queueprint('*'*10, '以下是Queue()的代码,先进先出', "*"*10)q1 = queue.Queue() # 先进先出队列q1.put(1)q1.put(6)q1.put(3)print(q1.get()) # 第一个被取出来的是 1print(q1.get()) # 第二个被取出来的是 6print('*'*10, '以下是LifoQueue()的代码，先结后出', "*"*10)q2 = queue.LifoQueue() # 其实是栈，先进后出队列q2.put(10)q2.put(15)q2.put(20)print(q2.get()) # 第一个被取出来的是 20print(q2.get()) # 第二个被取出来的是 15print('*'*10, '以下是PriorityQueue()的代码,优先级队列', "*"*10)q3 = queue.PriorityQueue() # 优先级队列,当第一个参数相同时，按第二个参数ACSⅡ码进行排序q3.put(100, 'd')q3.put(150, 'a')q3.put(200, 'c')q3.put(150, 'b')print(q3.get()) # 第一个被取出来的是 (100, 'd')print(q3.get()) # 第二个被取出来的是 (150, 'a')print(q3.get()) # 第三个被取出来的是 (150, 'b') 运行结果如下:]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程之定时器-Day41]]></title>
    <url>%2F423b33d2.html</url>
    <content type="text"><![CDATA[线程之定时器-Day41代码如下：123456789101112131415# Author : 渝周郎# Time : 2018/12/24 22:11import timefrom threading import Timerdef func(): print('%s:同步时间成功！'% time.ctime())while True: t = Timer(5, func).start() time.sleep(5) 运行结果如下:]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程之条件-Day41]]></title>
    <url>%2Fb0b02721.html</url>
    <content type="text"><![CDATA[线程之条件-Day41 主要是四个函数函数的运用：acquire()、release()：使用wait()和notify()的前后必须得用这两个函数wait()、notify(int类型) 代码如下：1234567891011121314151617181920212223# Author : 渝周郎# Time : 2018/12/24 21:25from threading import Condition, Threaddef func(con, i): con.acquire() con.wait() # 默认False状态会影响wait一直处于等待状态 print('这是第%s个循环' % i) con.release()con = Condition() # Condition默认状态为Falsefor i in range(10): Thread(target=func, args=(con, i)).start()while True: msg = int(input('&gt;&gt;&gt;')) con.acquire() con.notify(msg) # notify相当于造几把钥匙 con.release() 运行结果如下:]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程之事件-Day41]]></title>
    <url>%2Fab53b0f3.html</url>
    <content type="text"><![CDATA[线程之事件-Day41代码如下：123456789101112131415161718192021222324252627282930import timeimport randomfrom threading import Thread, Event# 通过一个检测数据库连接状态的列子说明Event是如何使用的def check_db(e): # 不定时返回Event的状态为True time.sleep(random.randint(0,3)) e.set()def connect_db(e): # 连接数据库函数 count = 0 # 数据库失败连接次数 while count &lt; 3: # 失败重复连接3次 e.wait(1) # 设置等待连接时间为0.5秒 if e.is_set(): print('数据库连接成功!') break else: count +=1 print('第%s次数据库连接失败！'% count) else: # 超过3次连接失败，主动抛出异常错误！ raise TimeoutError('数据库连接超时!')event =Event()t1 = Thread(target=check_db, args=(event, ))t2 = Thread(target=connect_db, args=(event, ))t1.start()t2.start() 运行结果如下:]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程之信号量-Day41]]></title>
    <url>%2Fe9bb2cf3.html</url>
    <content type="text"><![CDATA[线程之信号量-Day41代码如下：12345678910111213141516import timefrom threading import Thread, Semaphoredef func(sem, a, b): sem.acquire() time.sleep(1) print(a+b) sem.release()sem = Semaphore(3) # 同时运行3个线程计算for i in range(10): t = Thread(target=func, args=(sem, i, i*5)) t.start() 运行结果如下:]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程锁-Day41]]></title>
    <url>%2F64fd2211.html</url>
    <content type="text"><![CDATA[线程锁（Lock：互斥锁,RLock:递归锁）-Day41 通过科学家吃面的例子演示Lock和RLock的区别 1. Lock()代码演示加锁和不加锁的区别如下：123456789101112131415161718192021222324import timefrom threading import Thread,Lockdef func(lock): global n lock.acquire() # 此处如果不加lock,程序运行结果是9，上锁后保证线程一个一个计算 tmp = n time.sleep(0.1) n = tmp-1 lock.release()n =10lock = Lock()t_lst =[]for i in range(10): t = Thread(target=func, args=(lock, )) t.start() t_lst.append(t)for t in t_lst: t.join()print(n) 运行结果如下:1230Process finished with exit code 0 2. Lock()代码演示科学家吃面条如下：1234567891011121314151617181920212223242526272829303132import timefrom threading import Thread,Lock# 科学家吃面条演示死锁例子lock_mt = Lock() # 加一把面条锁lock_kz = Lock() # 加一把筷子锁def eat1(name): # 正常加锁，不会死锁 lock_mt.acquire() print('%s拿到面条'% name) lock_kz.acquire() print('%s拿到筷子'% name) print('%s吃面啦'% name) lock_kz.release() lock_mt.release()def eat2(name): # 加上时间延迟，会导致死锁 lock_kz.acquire() print('%s拿到筷子'% name) time.sleep(1) lock_mt.acquire() print('%s拿到面条'% name) print('%s吃面啦'% name) lock_mt.release() lock_kz.release()for i in range(10): Thread(target=eat1, args=('王五',)).start() Thread(target=eat1, args=('张三',)).start() Thread(target=eat2, args=('李四',)).start() Thread(target=eat2, args=('文武',)).start() 运行结果如下:123456789王五拿到面条王五拿到筷子王五吃面啦张三拿到面条张三拿到筷子张三吃面啦李四拿到筷子王五拿到面条--------------&gt;此处程序被挂起，没有结束 3. RLock()代码演示科学家吃面条如下：12345678910111213141516171819202122232425262728293031import timefrom threading import Thread,Lock# 科学家吃面条演示递归锁例子lock_mt = lock_kz = RLock()def eat1(name): # 正常加锁，不会死锁 lock_mt.acquire() print('%s拿到面条'% name) lock_kz.acquire() print('%s拿到筷子'% name) print('%s吃面啦'% name) lock_kz.release() lock_mt.release()def eat2(name): # 加上时间延迟，递归锁不会锁死 lock_kz.acquire() print('%s拿到筷子'% name) time.sleep(1) lock_mt.acquire() print('%s拿到面条'% name) print('%s吃面啦'% name) lock_mt.release() lock_kz.release()for i in range(10): Thread(target=eat1, args=('王五',)).start() Thread(target=eat1, args=('张三',)).start() Thread(target=eat2, args=('李四',)).start() Thread(target=eat2, args=('文武',)).start() 运行结果如下:1234567891011121314151617181920212223242526272829303132333435363738王五拿到面条王五拿到筷子王五吃面啦张三拿到面条张三拿到筷子张三吃面啦李四拿到筷子李四拿到面条李四吃面啦文武拿到筷子文武拿到面条文武吃面啦王五拿到面条王五拿到筷子王五吃面啦张三拿到面条张三拿到筷子张三吃面啦李四拿到筷子李四拿到面条李四吃面啦文武拿到筷子文武拿到面条文武吃面啦王五拿到面条王五拿到筷子王五吃面啦张三拿到面条张三拿到筷子张三吃面啦李四拿到筷子李四拿到面条李四吃面啦文武拿到筷子文武拿到面条文武吃面啦Process finished with exit code 0]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程实现socket_server-Day40]]></title>
    <url>%2F86538d29.html</url>
    <content type="text"><![CDATA[Day40 线程实现socket_server 以下是server端代码： 1234567891011121314151617181920212223242526# Author : 渝周郎# Time : 2018/12/16 21:49import socketfrom threading import Threaddef chat(conn, addr): print('addr:', addr) while True: msg = input('&gt;&gt;&gt;').encode('utf-8') conn.send(msg) rev = conn.recv(1024).decode('utf-8') print('%s发来消息：%s'%(addr, rev)) conn.close()if __name__ == '__main__': sk = socket.socket() sk.bind(('127.0.0.1', 4567)) sk.listen() while True: conn, addr = sk.accept() Thread(target=chat, args=(conn, addr)).start() sk.close() 以下是client端代码： 123456789101112131415# Author : 渝周郎# Time : 2018/12/16 21:49import socketsk = socket.socket()sk.connect(('127.0.0.1', 4567))while True: rev = sk.recv(1024).decode('utf-8') print(rev) msg = input('&gt;&gt;&gt;').encode('utf-8') sk.send(msg)sk.close()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程池回调函数之爬取数据的列子-Day39]]></title>
    <url>%2F625f57ac.html</url>
    <content type="text"><![CDATA[进程池回调函数之爬取数据的列子-Day39 通过requests模块简单的get函数演示进程池 代码如下：123456789101112131415161718192021222324252627282930import requestsfrom multiprocessing import Pooldef get(url): res = requests.get(url) if res.status_code == 200: return url,res.contentdef call_back(args): url, content = args print(url,len(content))if __name__ == '__main__': p = Pool(5) urls = [ 'http://www.baidu.com', 'http://www.163.com', 'http://www.sohu.com', 'http://www.sina.com', 'http://www.mi.com', 'http://www.360.cn' ] for url in urls: p.apply_async(get,args=(url,),callback=call_back) p.close() p.join() 运行结果如下:1234567http://www.163.com 700207http://www.baidu.com 2381http://www.sohu.com 211896http://www.mi.com 322315http://www.360.cn 76607Process finished with exit code 0]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程池的返回值-Day39]]></title>
    <url>%2F41025f99.html</url>
    <content type="text"><![CDATA[Day39 进程池的返回值 以下是同步执行Pool.apply()代码： 1234567891011121314151617# Author : 渝周郎# Time : 2018/12/11 22:40import timefrom multiprocessing import Pooldef func(n): # for i in range(n): time.sleep(0.5) return n * n if __name__ == '__main__': p = Pool(5) for i in range(10): ret = p.apply(func, args=(i,)) print(ret) 以下是异步Pool.apply_async()代码： 12345678910111213141516171819# Author : 渝周郎# Time : 2018/12/11 22:40import timefrom multiprocessing import Pooldef func(n): # for i in range(n): time.sleep(0.5) return n * nif __name__ == '__main__': p = Pool(5) p_ls = [] for i in range(10): ret = p.apply_async(func, args=(i,)) p_ls.append(ret) for p in p_ls: print(p.get()) 以下是执行结果(异步方式是5个结果一起打印，而同步方式是一个一个打印结果)1234567891011120149162536496481Process finished with exit code 0 以下是map（）返回值123456789101112131415# Author : 渝周郎# Time : 2018/12/11 22:40import timefrom multiprocessing import Pooldef func(n): # for i in range(n): time.sleep(0.5) return n * n# 第三种方式 mapif __name__ == '__main__': p = Pool(5) ret = p.map(func, range(10)) print(ret) 以下是map()执行结果123[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]Process finished with exit code 0]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程池的回调函数-Day39]]></title>
    <url>%2F10169f3b.html</url>
    <content type="text"><![CDATA[Day39 进程池的回调函数 以下代码： 1234567891011121314151617181920212223# Author : 渝周郎# Time : 2018/12/12 21:51import osfrom multiprocessing import Pooldef func1(n): print('in func1', os.getpid()) return n * ndef func2(nn): print('in func2', os.getpid()) print(nn)if __name__ == '__main__': p = Pool(5) print('主进程:', os.getpid()) # 以下代码是先异步执行func1内容，然后将func1的返回值传递到func2，作为func2的参数传入并运行func2函数. p.apply_async(func1, args=(10, ), callback=func2) p.close() p.join() 以下是执行结果123456主进程: 10260in func1 12608in func2 10260100Process finished with exit code 0]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程池实现socket_server异步功能-Day39]]></title>
    <url>%2Fc8663abe.html</url>
    <content type="text"><![CDATA[Day39 进程池实现socket_server异步功能 以下是server端代码： 123456789101112131415161718192021222324# Author : 渝周郎# Time : 2018/12/11 21:00import socketfrom multiprocessing import Pooldef func(cn): # msg = input('&gt;&gt;&gt;').encode('utf-8') cn.send(b'hello') ret = cn.recv(1024).decode('utf-8') print(ret) cn.close()if __name__ == '__main__': p = Pool(5) sk = socket.socket() sk.bind(('127.0.0.1', 8080)) sk.listen() while True: conn, addr = sk.accept() p.apply_async(func, args=(conn,)) sk.close() 以下是client端代码： 1234567891011# Author : 渝周郎# Time : 2018/12/11 21:00import socketsk = socket.socket()sk.connect(('127.0.0.1', 8080))ret = sk.recv(1024).decode('utf-8')print(ret)msg = input('&gt;&gt;&gt;').encode('utf-8')sk.send(msg)sk.close()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进程池-Day39]]></title>
    <url>%2F525adb7e.html</url>
    <content type="text"><![CDATA[Day39 Python进程池 multiprocess模块中的Pool类有以下方法： pl = Pool(5) 实例化对象，’5’ 代表5个队列 pl.map() 同map方法一样,map(funcname, iterable) 默认异步的执行任务，且自带close和join pl.apply() 同步调用 pl.apply_async() 异步调用 和主进程完全异步 需要手动close 和 join 以下是同步方式代码： 123456789101112131415161718# Author : 渝周郎# Time : 2018/12/11 20:23import timeimport osfrom multiprocessing import Pooldef func(n): print('开始： %s' % n, os.getpid()) time.sleep(1) print('结束： %s' % n, os.getpid())if __name__ == '__main__': pl = Pool(5) for i in range(10): pl.apply(func, args=(i,)) # Pool.apply 同步方式 以下是运行结果：12345678910111213141516171819202122开始： 0 9760结束： 0 9760开始： 1 12060结束： 1 12060开始： 2 3208结束： 2 3208开始： 3 4196结束： 3 4196开始： 4 10144结束： 4 10144开始： 5 9760结束： 5 9760开始： 6 12060结束： 6 12060开始： 7 3208结束： 7 3208开始： 8 4196结束： 8 4196开始： 9 10144结束： 9 10144Process finished with exit code 0 以下是异步方式:123456789101112131415161718192021# Author : 渝周郎# Time : 2018/12/11 20:23import timeimport osfrom multiprocessing import Pooldef func(n): print('开始： %s' % n, os.getpid()) time.sleep(1) print('结束： %s' % n, os.getpid())if __name__ == '__main__': pl = Pool(5) for i in range(10): # pl.apply(func, args=(i,)) # Pool.apply 同步方式 pl.apply_async(func, args=(i,)) # Pool.apply_async 异步方式 pl.close() # 异步方式先要结束进程池接收任务 pl.join() # 异步方式感知进程池进程结束 以下是运行结果:12345678910111213141516171819202122开始： 0 6592开始： 1 4844开始： 2 5436开始： 3 3708开始： 4 1352结束： 0 6592开始： 5 6592结束： 1 4844开始： 6 4844结束： 2 5436开始： 7 5436结束： 3 3708开始： 8 3708结束： 4 1352开始： 9 1352结束： 5 6592结束： 6 4844结束： 7 5436结束： 8 3708结束： 9 1352Process finished with exit code 0]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进程池效率测试-Day39]]></title>
    <url>%2Fd6c25498.html</url>
    <content type="text"><![CDATA[Day39 进程池效率测试 第一种方式 123456789101112131415161718import timefrom multiprocessing import Process# 第一种传统方式进行简单计算def func(n): print(n * 2)if __name__ == '__main__': s = time.time() plst = [] for i in range(100): p = Process(target=func, args=(100,)) p.start() plst.append(p) for p in plst: p.join() print(time.time()-s) 运行结果如下（总共运行了29秒）：1234567891011121314151620020020020020020020020020020020020020029.747446298599243Process finished with exit code 0 第二种方式123456789101112import timefrom multiprocessing import Pool# 第二种设置进程池进行简单计算def func(n): print(n * 2)if __name__ == '__main__': s = time.time() pl = Pool(5) # 5个进程 pl.map(func, range(100)) # 100个任务 print(time.time()-s) 运行结果如下（1.92秒）123456789101112131415161741761781801821841861881901921941961981.9248509407043457Process finished with exit code 0]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python管道-Day38]]></title>
    <url>%2F42a100b5.html</url>
    <content type="text"><![CDATA[Day38 Python管道 multiprocess模块中的Pipe类有以下方法： conn1,conn2 = Pipe() 进行实例化，返回两个参数 conn1和conn2一个使用send()方法,另一个使用recv()方法，使用完后要用close()方法关闭 以下是用管道（Pipe）展现生产者与消费者模型的代码：12345678910111213141516171819202122232425262728293031323334353637383940# Author : 渝周郎# Time : 2018/12/9 21:19import timeimport randomfrom multiprocessing import Process, Pipedef sc(name, food, conn1, conn2): conn2.close() for i in range(5): time.sleep(random.randint(1, 4)) f = '%s制作了%s%s' % (name, food, i) print(f) conn1.send(f)# conn.send(None) # 生产端完成后发送一个None给消费端进行判断是否结束。def xf(name, conn1, conn2): conn1.close() while True: try: f = conn2.recv() # if f is None: break # 第一种防止进程挂起的方法是，在生 产端最后一条数据发送None，消费端对None判断。 print('%s消费了%s' % (name, f)) time.sleep(random.randint(1, 3)) except EOFError: # 第二种方法是捕获 EOFError 异常 break conn2.close()if __name__ == '__main__': conn1, conn2 = Pipe() p_sc = Process(target=sc, args=('李红', '包子', conn1, conn2)) p_xf = Process(target=xf, args=('王总', conn1, conn2)) p_sc.start() p_xf.start() conn1.close() # 主进程和线程中conn1和conn2都要关闭 conn2.close() 以下是运行结果：12345678910李红制作了包子0王总消费了李红制作了包子0李红制作了包子1王总消费了李红制作了包子1李红制作了包子2王总消费了李红制作了包子2李红制作了包子3王总消费了李红制作了包子3李红制作了包子4王总消费了李红制作了包子4]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python生产者消费者模型-Day38]]></title>
    <url>%2Fc50e7202.html</url>
    <content type="text"><![CDATA[Python生产者与消费者模型-Day38 multiprocess模块中的JoinableQueue类常用方式： task_done() 常和get方法搭配使用 join 常和put方法搭配使用 代码如下：1234567891011121314151617181920212223242526272829from multiprocessing import Process, JoinableQueueimport time, randomdef sc(name, food, q): for i in range(10): time.sleep(random.randint(3,5)) print('%s生产了%s%d'%(name, food,i)) q.put('%s生产了%s%d'%(name, food,i)) q.join() # q.join 常和put搭配使用def xf(name, q): while True: food = q.get() print('\033[31m%s消费了→%s\033[0m'%(name, food)) time.sleep(random.randint(1,3)) q.task_done() # q.task_done() 常和get搭配使用if __name__ == '__main__': q = JoinableQueue(10) psc1 = Process(target=sc, args=('王近', '包子', q)) psc2 = Process(target=sc, args=('李武', '油条', q)) pxf1 = Process(target=xf, args=('五杀', q)) pxf2 = Process(target=xf, args=('好评', q)) psc1.start() psc2.start() pxf1.daemon=True # 设置为守护进程，当主线程的代码执行完毕时，子线程自动结束 pxf2.daemon=True pxf1.start() pxf2.start() psc1.join() # 感知一个进程的结束 psc2.join() 运行结果如下:12345678910111213141516王近生产了包子0好评消费了→王近生产了包子0李武生产了油条0五杀消费了→李武生产了油条0王近生产了包子1好评消费了→王近生产了包子1李武生产了油条1五杀消费了→李武生产了油条1王近生产了包子2好评消费了→王近生产了包子2李武生产了油条2五杀消费了→李武生产了油条2王近生产了包子3好评消费了→王近生产了包子3李武生产了油条3五杀消费了→李武生产了油条3]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python多线程之队列]]></title>
    <url>%2Fundefined.html</url>
    <content type="text"><![CDATA[Day38 Python多线程之队列 multiprocessing模块中的Queue类有如下方法 .put() 在队列池中加入一个进程 .full() 查看队列池是否已满？如果已满，就阻塞 get() 在队列池中取出一个进程 .empty() 查看队列池是否为空？如果为空，就阻塞12345678910111213141516from multiprocessing import Process, Queuedef shengchan(q): q.put('产生一个数据')def xiaohao(q): print(q.get())if __name__ == '__main__': q = Queue() p = Process(target=shengchan, args=(q,)) p.start() x = Process(target=xiaohao, args=(q,)) x.start()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MSSQL Errlog清理及变更存储位置]]></title>
    <url>%2Fundefined.html</url>
    <content type="text"><![CDATA[一次整理MSSQL数据库时发现Microsoft SQL Server\MSSQL10_50.MSSQLSERVER\MSSQL\Log目录下面错误日志文件很大，特对目录下的错误日志文件进行瘦身操作，整个流程如下：由于默认情况下，SQL Server 保存 7 个 ErrorLog 文件，名为： ErrorLog ErrorLog.1 ErrorLog.2 ErrorLog.3 ErrorLog.4 ErrorLog.5 ErrorLog.6 下面开始操作清除错误日志文件存档 （循环执行6次，请清除6个日志文件）123&gt; EXEC sp_cycle_errorlog&gt; GO&gt; 修改Errlog的存放位置12345&gt; 打开 Sql Server 配置管理器 --&gt; Sql Server 服务 --&gt; Sql Server (MSSQLSERVER) --&gt; 属性 --&gt; 高级&gt; 修改“转储目录”，将文件夹修改为新的路径&gt; 修改“启动参数”，将-e后的文件夹修改为新的路径&gt; 然后从新启动 Sql Server (MSSQLSERVER) ，再次执行方法一得指令，发现 ERRORLOG 文件就在新的文件夹内产生了&gt;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python关键词整理]]></title>
    <url>%2Fa42de8bb.html</url>
    <content type="text"><![CDATA[statements 语句 print() 输出 quit() 退出 exit() 退出 ctrl+d (输入文件结束符)结束输入并退出 int 整型数 float 浮点型数 complex 复数 bool 布尔 True 真 False 假 str 字符串 list 列表 None 空值 expression 表达式 del 删除 help() 帮助 is 是 not is 不是 id() 查询内存地址 -5~256 小整数池 refrence count 引用计数 abs 取绝对值 round 四舍五入 pow 幂运算 input() 输入 sep 两值之间分隔符 end 结束（内容） if 如果 elif 否则如果 else 否则 pass 过 not 布尔 非 and 布尔 与 or 布尔 或 man ascii 终端查询命令 ascii 编码表 Unicode 统一编码表 Unicode16 16位 Unicode32 32位 len(x) 返回个数 raw 原始字符串(r”hello”) in 是否出现过 not in 没有出现 index 索引([]) slice 切片([::]) bin() 整数转二进制 oct() 整数转八进制 hex() 整数转十六进制 max() 求最大值 min() 最小值 ord() 字符对应（转）数字 chr() 数字对应（转）字符 while 循环 for 循环（遍历） break 跳出循环 list 列表 tuple 元组 dict 字典 range 整数序列生成器 step 步长 continue 跳过循环 iterable 可迭代对象 sum() 求和 any() 一个为真则为真 all() 所有真为真 s.split(sep) sep:分隔符（分隔字符串返回列表） ‘#’.join() [1,2,3]返回”1#2#3” copy(shallow copy) 浅拷贝 deepcopy 深拷贝 reversed 顺序翻转 sorted() 排序序列 key 键 value 值 set 集合 frozenset 固定集合 byte 字节（0~255） bytes() 字节串 bytearray() 字节数组 def (function) 函数 return 返回 args 参数 args=None 缺省参数 *args 元组传参 **kwargs 字典传参 local variable 局部变量 global variable 全局变量 globals() 返回全局变量字典 locals() 返回局部变量字典 Local(function) L 局部（作用域） Enclosing function locals E 外部嵌套 Global(module) G 全局（模块） Builtin(Python) B 内建 global 声明全局变量 nonlocal 声明外部嵌套 lambda 匿名函数（参数：返回结果） eval() 字符串当表达式执行 exec() 字符串当程序执行 High Order Function 高阶函数 map() (函数，iterable) filter() (函数，iterable) sorted() (iterable,key=函数，reverse=False) recursion 递归 closure 闭包 Module 模块 builtins 内建模块 import Mouble 导入模块 from Mouble import * 导入模块内属性 dir() 返回所有属性列表 math 数学模块 time 时间模块 random 随机模块 sys系统 模块（内建） @Function 装饰器函数 pip3 installtensorflow 模块安装 sys.path 路径列表 __doc__ 文档字符串 __file__ 路径名 __name__ 模块自身名 __all__ 可导出属性列表 package 包 _name 隐藏属性name __init__.py 声明包文件 try-except 接受处理异常 try-finally 执行必要语句 try 异常 as 改名 except 截取异常类型 else 正常结束 finally 强制执行 raise 发送错误 assert 限制条件发送 assert True–&gt;执行后续语句 Iterator 迭代器 iter() 可迭代对象生产迭代器 next() 迭代器内顺序取值 Generator 生成器 yield 函数内表达式（生成器函数） [x for x in range() if] 生成器表达式 zip() 两个或以上可迭代生成元组 enumerate() 生成带索引对象 可定义开始下标 File 文件 open() 打开文件 File.close() 关闭文件 gb2312 6763汉子 gbk 国标21003汉子 gb18030 27533汉子 UTF-8 Unicode ASCII 256字符 Ojbect-Oriented Programing 对象 class 类 method 实例 attribute 实例属性（变量） __init__() 初始化方法 __del__() 析构方法 __dict__ 自身变量的字典 __class__ 实例的类 type(obj) 返回类型 isinstance() 判断是否为某个类 self 类方法必有的参数（自己） object 对象（类） instance 实例 @classmethod 装饰为类的方法 @staticmethod 静态方法（类内普通函数） inheritance 继承（单继承） multiple inheritance 多继承 derived 派生 base class 基类 super class 超类 father class 父类 derived class 派生类 child class 子类 override 覆盖 super() 调用父类覆盖方法 enclosure 封装 __name 私有属性name polymorphic 多态（静态/动态） __mro__ 类的方法查找顺序列表 repr(obj) 返回表达式字符串 str(obj) 返回字符串 内建函数重写 __repr__ 对象装字符串（表达式字符串） __str__ 函数重写（字符串） __abs__ 绝对值 __len__ 序列长度，必须返回整数 __reversed__ 排序，必须返回可迭代对象 __round__ 四舍五入函数 数值转换函数重写 __complex__ 复数函数 __int__ 整数函数 __float__ 浮点数函数 __bool__ 布尔函数（特殊） __next__ 迭代器 getattr(obj,”name”[default]) name为字符串 hasattr(obj,”name”) 判断有没有name属性 setattr(obj,”name”,value) name赋值为value delattr(obj,”name”) 删除name属性 with 异常发时自动管理 __enter__ with开始自动调用 __exit__ with调用 判断是否异常 __eixt__(self,exc_type,exc_val,exc_tb) exc_type 错误类型 exc_val 错误值 exc_tb 追踪 运算符重载方法名 运算符和表达式 说明 __add__(self,rhs) self+rhs 加法 __sub__(self,rhs) self-rhs 减法 __mul__(self,rhs) self*rhs 乘法 __truediv__(self,rhs) self/rhs 除法 __floordiv__(self,rhs) self//rhs 地板除 __mod__(self,rhs) self%rhs 取模（求余） __pow__(self,rhs) self**rhs 幂rhs(right hand side) 右手边反向算术运算符重载 __radd__(self,lhs) lhs+self 加法 __rsub__(self,lhs) lhs-self 减法 __rmul__(self,lhs) lhs*self 乘法 __rtruediv__(self,lhs) lhs/self 除法 __rfloordiv__(self,lhs) lhs//self 地板除 __rmod__(self,lhs) lhs%self 取模（求余） __rpow__(self,lhs) lhs**self 幂lhs(left hand side) 右手边 复合赋值算术运算符重载 __iadd__(self,lhs) lhs_=self 加法 __isub__(self,lhs) lhs-=self 减法 __imul__(self,lhs) lhs*=self 乘法 __itruediv__(self,lhs) lhs/=self 除法 __ifloordiv__(self,lhs) lhs//=self 地板除 __imod__(self,lhs) lhs%=self 取模（求余） __ipow__(self,lhs) lhs**=self 幂优先调用 TypeError异常复合赋值算术运算符重载 __lt__(self,rhs) self&lt;rhs 小于 __le__(self,rhs) self&lt;=rhs 小于等于 __gt__(self,rhs) self&gt;rhs 大于 __ge__(self,rhs) self&gt;=rhs 大于等于 __eq__(self,rhs) self==rhs 等于 __ne__(self,rhs) self!=rhs 不等于 位运算符重载 __invert__(self) ~self 取反（一元运算符） __and__(self,rhs) self&amp;rhs 位与 __or__(self,rhs) self&amp;rhs 位或 __xor__(self,rhs) self^rhs 位异或 __lshift__(self,rhs) self&lt;&lt;rhs 左移 __rshift__(self&gt;&gt;rhs) self&gt;&gt;rhs 右移 反向位运算符重载 __rand__(self,lhs) lhs&amp;self 位与 __ror__(self,lhs) lhs\ self 位或 __rxor__(self,lhs) lhs^self 位 异或 __rlshift__(self,lhs) lhs&lt;&lt;self 左移 __rrshift__(self,lhs) lhs&gt;&gt;self 右移 复合赋值位运算符 __iand__(self,rhs) self&amp;=rhs 位与 __ior__(self,rhs) self\ =rhs 位或 __ixor__(self,rhs) self^=rhs 位异或 __ilshift__(self,rhs) self&lt;&lt;=rhs 左移 __irshift(self,rhs) self&gt;&gt;=rhs 右移 一元运算符重载 __invert__(self) ~self 取反（一元运算符） __pos__(self) +self 正号 __neg__(self) .self 负号 索引和切片运算符的重载 __getitem__(self,i) x=self 索引/切片取值 __setitem__(self,i,val) self=val 索引/切片赋值 __delitem__(self,i) del self 删除索引/切片 slice(start=None,stop=None,step=None) 等同于[::]切片]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown_gantt]]></title>
    <url>%2Faf95a0d3.html</url>
    <content type="text"><![CDATA[我的第一个甘特图123456789101112gantt title Python学习计划 dateFormat YYYY-MM-DD section 语法学习 类型 :done, a1, 09-07, 20d 循环 :done, a2, after a1, 1d section 对象 函数 :active, a3, after a2, 2d 类 :a4, after a3, 2d 对象 :a5, after a4,2d section 网络 socket学习 :a6, after a5, 3d]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo修改端口]]></title>
    <url>%2F5cc2837.html</url>
    <content type="text"><![CDATA[hexo修改访问端口的方法 修改端口有两种方法： 启动运行服务时指定端口(将4000端口更改为80端口)，需要每次都要指定端口，命令如下: hexo s -p 80 2、一劳永逸，直接更改js文件，操作如下： 打开以下文件 你博客所在目录\node_modules\hexo-server\index.js后将port更改为80即可，如下图所示]]></content>
  </entry>
</search>
